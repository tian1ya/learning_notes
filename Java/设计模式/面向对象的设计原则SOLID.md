[所有这系列笔记全都是来源于博客](<http://m.biancheng.net/view/1322.html>)

---

### 面向对象的设计原则SOLID

* 单一职责
* 开闭原则
* 里氏替换原则
* 接口隔离原则
* 依赖倒置
* 迪米特法则：最少知识

---

**单一职责原则**

> **该原则指出软件模块应该只能有一个理由。**
>
> 如果类需要更改的原因不止一个，那么每个类都可能引入印象其他类的更改。

**开闭原则**

> **定义**：软件实体应当**对扩展开放，对修改关闭**（Software entities should be open for extension，but closed for modification）
>
> **含义**：当应用的需求发送改变的时候，在不修改原来软件实体的源代码的前提下，可以扩展模块的功能，使其买足新的需求。
>
> 以上可以是的实体拥有一定的适应性和灵活性的同时具备了稳定性和延续性。
>
> **实现方法**：
>
> 通过抽象约束，封装变化，来实现该原则，即通过接口或者抽象类作为软件实体定义一个相对文档的抽象层，而将想吐的可变因素封装再期具体的实现类中。
>
> 因为抽象的灵活性好，适应性广，只要抽象合理，就可以几本保持软件架构的稳定

**里氏替换原则**

> **定义**： 继承必须确保超类所拥有的性质再子类中任然成立, 父类出现的地方都可以替换为子类，因为子类拥有父类的所有方法
>
> **含义**：这条原则阐述了有关继承的一些原则，也就是什么时候该使用继承，什么时候不该使用继承，也反应了基类和子类之间的关系，是对开闭原则的补充
>
> **作用**：是实现开闭原则的重要方式之一。克服了继承中重写父类造成可复用性变差的特点。
>
> 事动作正确的保证，即类的扩展不会给已有的系统引入新的错误，
>
> **实现方法**：子类可以扩展父类的功能，但是不能改变父类原有的功能，**也就是说继承父类的时候，除了添加新的方法完成新增功能之外，尽量不要重写父类的方法(派生类型应该像其父类型那样表现，不应该破坏它的行为)**。里氏替换原则的例子，最有名的是“正方形不是长方形”。当然还会有其他的例子，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。
>
> ```java
> public class lishiyuanze {
>     public static void main(String[] args) {
>         YanZi yanZi = new YanZi();
>         yanZi.setSpeed(12);
>         double flyTime = yanZi.getFlyTime(120);
>         System.out.println("YanZi fly time" + flyTime);
> 
>         QiE qiE = new QiE();
>         qiE.setSpeed(12);
>         try {
> 
>             double flyTime1 = qiE.getFlyTime(120);
>         }catch (Exception e){
>             System.out.println("计算发送错误了");
>         }
>     }
> }
> 
> class Bird{
>     double speed;
> 
>     public void setSpeed(double speed) {
>         this.speed = speed;
>     }
>     public double getFlyTime(double distance) {
>         return distance/speed;
>     }
> }
> 
> class YanZi extends Bird{}
> 
> class QiE extends Bird{
>     double speed;
>     public void setSpeed(double speed) {
>         this.speed = 0;
>     }
> }
> 
> ```

**依赖倒置原则**

> **定义**：高层模块不应该依赖底层模块，两者都应该依赖期抽象，抽象不应该依赖细节，细节应该依赖抽象，
>
> 其核心思想就是 **面向接口编程，不要面向实现编程**。
>
> **这也是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合**
>
> 再软件设计中，**细节会有多变性，而抽象层则相对稳定**，因此以抽象层为基础搭建起来的架构要比以细节为基础大家起来的架构稳定的多。
>
> ```java
> interface shop{
>     public void sell();
> }
> 
> class shoppingOne implements shop{
> 
>     @Override
>     public void sell() {
>         System.out.println("shoppingOne shoping......");
>     }
> }
> 
> class shoppingTwo implements shop{
> 
>     @Override
>     public void sell() {
>         System.out.println("shoppingTwo shoping......");
>     }
> }
> 
> class customer{
>     public void shopping(shop shop){
>         shop.sell();
>     }
> }
> 
> public class yilaidaozhi {
> 
>     public static void main(String[] args) {
>         shoppingOne shoppingOne = new shoppingOne();
> 
>         shoppingTwo shoppingTwo = new shoppingTwo();
> 
>         customer customer = new customer();
> 
>         customer.shopping(shoppingOne);
>         customer.shopping(shoppingTwo);
> 
>     }
> }
> ```

**单一职责**

> **定义**： 单一功能原则，职责指的是变化的原因，单一职责规定一个类应该有且只有一个引起它变化的原因，否则类应该被产分，对应不应该有太多职责，如果包含太多的职责，那么会存在以下俩个缺点
>
> > 1. 一个职责的变化，可能会削弱或者已知这个类实现其它职责的能力
> > 2. 当客户端需要该对象的某一个职责的时候，不得不讲其它不需要的职责全部包含进来，造成代码冗余和浪费。
>
> 优点：
>
> > 单一职责的核心就是控制累的颗粒度大小，将对象解耦，提高内聚性
> >
> > 1. 降低类的复杂性，一个类只负责一个职责，逻辑肯定比负责多项职责简单的多。
> > 2. 提高类的可读性，复杂性降低，
> > 3. 系统的可维护性增加，
> > 4. 变更引起的风险降低，单一职责，当修改一个功能的时候，可以显著降低对其他功能的影响。
>
> **实现方法**：
>
> 这个原则中，最简单但是，最不容易把握的就是，职责的划分，如何划分职责，然后将其分离，再封装到不同的类中或则，或者模块中

**接口隔离原则**

> **定义**: **客户端不应该被迫依赖于它不实用的方法/类**，一个类对另一个类的依赖应该建立在最小的接口之上，为各个类建立它们需要的专用接口，而不要视图建立一个很庞大的接口，共所有依赖它的类去调用。
>
> 隔离原则和单一原则都是为了提高类的内敛性，降低它们之间的耦合性，体现了封装的思想，二者也有不同
>
> * 单一隔离注重的是职责，而接口隔离注重的是对借口哦的依赖的隔离
> * 单一职责主要的是约束类，它针对的是程序中的实现和细节，借口隔离主要是约束接口，
>
> **接口隔离的实现**：一下几个原则
>
> * 接口尽量小，但是有限度，一个接口只服务于一个字模块或者业务逻辑
> * 为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法
> * 提供内聚，减少对外交互，使接口用最少的方法去完成最多的事情。

**迪米特法则** ： 最少知识法则

> **定义**： 只与你的直接朋友交谈，不和陌生人说话，如果两个软件实体并无直接通信，那么就不应该发生直接的相互调用，可以通过第三方转发该调用，其目的是降低之间的耦合度，提供模块之间的独立性。
>
> 上面所说的**朋友**，当前对象本身，当前对象的成员对象，当前对象所创建的对象，当前对象的方法参数等，这些对象同当前对象存在联系，可以直接访问这些对象。
>
> **优点**：
>
> * 降低之间的耦合度，提供模块之间相对独立性。
> * 亲和度降低，提高类类的可复用率和系统的扩展性。

**合成复用原则**

> 要求软件再复用的时候，尽量使用组合或者聚合等关联关系实现，其次才是考虑继承
>
> 通常类的复用分为继承和合成两种方式，继承复用虽然简单和易实现有点，但是存在一下缺点，
>
> * 继承破坏类的封装性，因为继承父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
> * 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
> * 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。
>
> 组合聚合之后，可以讲已有对象纳入新对象中，使得称为新对象的一部分，新对象可以调用已有对象的功能。
>
> 1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
> 2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
> 3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

这 7 种设计原则是软件[设计模式](http://m.biancheng.net/design_pattern/)必须尽量遵循的原则，各种原则要求的侧重点不同。其中，**开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用**。