#### AtomicLong

![a](./pics/并行20.png)

底层均是在调用`unsafe` 的接口。

---

#### LongAdder

`AtomicLong` 通过`CAS` 提供了非阻塞的原子性操作，相比阻塞同步器`synchronized` 性能要好很多，但是当在高并发大量线程时候会同步去竞争一个线程，更新一个原子变量，但由于只有一个线程的`cas` 会操作成功，造成大量其他线程竞争失败，这些线程会无限循环不断自旋尝试`CAS` 的操作，白白浪费`CPU` 资源。

> `AtomicLong` 的瓶颈是多个线程同时竞争一个变量产生。

`LongAdder` 的做法就是将一个变量分为多个变量，让同样多的线程去竞争多个资源

![a](./pics/并行21.png)

其原理如下：多个线程在修改值得时候，会去争夺多个`Cell` 修改`Cell` 中得值，每个`Cell` 中得初始值都是0，如果线程获取`Cell` 失败之后，会去争夺其他`Cell` 并修改。

当获取结果值得时候，将多个`Cell` 得值累加`base`， 然后返回。

`Cell` 得初值均是`null`(没有初始化，占内存)， 只有在使用得时候从`base` 获取然后初始化。

学习`LongAdder` 需要明白以下几个问题

* `LondAdder` 得结构是怎样得
* 当前线程应该访问`Cell`数组里面得哪一个`Cell` 元素。
* 如何初始化`Cell` 数组
* `Cell` 是如何扩容得
* 线程分配`Cell` 元素有冲突后如何处理
* 如何保证线程操作被分配得`Cell` 原子性



##### `LondAdder` 得结构是怎样得 & 如何保证线程操作被分配得`Cell` 原子性

![a](./pics/并行22.png)

```java
@sun.misc.Contended static final class Cell {
    // 保证 cell 值得可见性
    volatile long value;
    Cell(long x) { value = x; }
    // 保证cell 值得原子性
    final boolean cas(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long valueOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class<?> ak = Cell.class;
            valueOffset = UNSAFE.objectFieldOffset
                (ak.getDeclaredField("value"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}
```

##### `LongAdder` 中得其他方法

* 获取结果值

```java
public long sum() {
    Cell[] as = cells; Cell a;
    long sum = base;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
```

这里再累加`cells` 得时候，并没有对其进行上锁，所以会有问题，获取结果值得时候，可能还有其他得线程在修改`cell`。

* 重置`Cell`

```java
public void reset() {
    Cell[] as = cells; Cell a;
    base = 0L;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                a.value = 0L;
        }
    }
}
```

* add 方法，重要

```java
public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    if ((as = cells) != null || !casBase(b = base, b + x)) { // 1
        // cells 为空，或者 cas 执行失败了，
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||    // 2
           (a = as[getProbe() & m]) == null ||         // 3
           !(uncontended = a.cas(v = a.value, v + x))) // 4 cells 中存在，能拿到一个cell，然后对这个cell 做cas操作
           
            longAccumulate(x, null, uncontended);       // 5 cells为空，或者不为空，但是cas 执行失败了
    }
}

// 当前线程得 threadLocalRandom 获取一个随机数，值一开始是0，
static final int getProbe() {
    return UNSAFE.getInt(Thread.currentThread(), PROBE);
}

// getProbe 回答上面得第二个问题
// 以及对cell得操作都是 cas 操作，保证其得原子性，也再次回答第6个问题

final void longAccumulate(long x, LongBinaryOperator fn,
                          boolean wasUncontended) {
    int h;
    if ((h = getProbe()) == 0) {
        ThreadLocalRandom.current(); // force initialization
        h = getProbe();
        wasUncontended = true;
    }
    boolean collide = false;                // True if last slot nonempty
    for (;;) { // 无限循环
        Cell[] as; Cell a; int n; long v;
        if ((as = cells) != null && (n = as.length) > 0) { // 当前cell不为空， 以下得分支回答了扩容问题
            if ((a = as[(n - 1) & h]) == null) { // 获取cells 中最好哪个cell
                if (cellsBusy == 0) {       // Try to attach new Cell
                    Cell r = new Cell(x);   // Optimistically create
                    if (cellsBusy == 0 && casCellsBusy()) { 
                        // cellsBusy=0，说明当前 cells没有在扩容以及初始化
                        // casCellsBusy() 将 cellsBusy=1，表示要扩容了
                        boolean created = false;
                        try {               // Recheck under lock
                            Cell[] rs; int m, j;
                            if ((rs = cells) != null &&
                                (m = rs.length) > 0 &&
                                rs[j = (m - 1) & h] == null) {
                                rs[j] = r; // 扩容赋值
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0; // 扩容完成
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                         // cell存在，那么更新，更新成功退出
                     fn.applyAsLong(v, x))))
                break;
            else if (n >= NCPU || cells != as)
                collide = false;            // At max size or stale
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 && casCellsBusy()) {
                // cell cas 执行时候发生了冲突，并且没有达到CPU个数，扩容
                try {
                    if (cells == as) {      // Expand table unless stale
                        Cell[] rs = new Cell[n << 1];
                        for (int i = 0; i < n; ++i)
                            rs[i] = as[i];
                        cells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            h = advanceProbe(h);
        }
        else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
            // 完成初始化
            boolean init = false;
            try {                           // Initialize table
                if (cells == as) {
                    Cell[] rs = new Cell[2];
                    rs[h & 1] = new Cell(x);
                    cells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        else if (casBase(v = base, ((fn == null) ? v + x :
                                    fn.applyAsLong(v, x))))
            break;                          // Fall back on using base
    }
}
```

* `LondAdder` 得结构是怎样得

  > 附图

* 当前线程应该访问`Cell`数组里面得哪一个`Cell` 元素。

  > getProb 函数获得一个 index，然后从cells[inde] 拿到 cel

* 如何初始化`Cell` 数组

  > 首次操作cell时候，发现cells 是空得

* `Cell` 是如何扩容得

  > 发生冲突，以及cells 个数 < NCPU

* 线程分配`Cell` 元素有冲突后如何处理

  > 竞争其他cell，以及扩容

* 如何保证线程操作被分配得`Cell` 原子性

  > 其操作均是 cas 得，以及cell中得 value 均是 volitile 得。

  