#### 对象引用、可变性和垃圾回收

---

Python 的变量类似于Java 中的引用式的变量，最好将它理解为附加在对象上的标注。

Python 中的赋值语句应该这么理解，读取的顺序应该是先读右边，也就是在右边先创建对象或获取，然后之后左边的变量绑定到对象上，可以这么理解，先将一个箱子打包好，然后再给这个箱子上贴上标签。

也就是说变量只是标签，箱子只有一个，但是箱子上可以有很多的标签，也就是多个变量可以贴到一个对象上。

每个变量都有标识、类型和值，对象一旦创建之后，标识就不会改变，可以讲标识理解为内存中的地址，id(obj)返回的是这个标识的数字表示。

---

**==  和 is 之间选择**

== 比较的是两个对象的值(对象中保存的值)，is 比较的是对象的标识。

---

**元组的相对不可变形**

元组和多数的Python 集合(list dict set)等一样，保存的都是对象的引用，如果引用的元素可变的，即便是元组本生不可变，元素依然是可变的，也就是说元组的不可变其实质是说，数据结构的物理内存不可变，与应用的对象无关。

```python
>>> t1 = (1,2,[2,3,4])
>>> t2 = (1,2,[2,3,4])
>>> t1 == t2
True
>>> t2[-1].append(4)
>>> t2 == t1
```

---

**深浅赋值**

默认的浅复制

```python
>>> l1 = [3,2,[2,3]]
>>> l2 = list(l1) // 构造函数复制
>>> l1 is l2      // 最外层在内存中的不是同一个
False   
>>> l1 == l2
True
>>> l1[0] is l2[0] // 但是里面的东西却在内存中是同一个
True
>>> l1[2] is l2[2]
True
```

**浅复制**: 构造方法做的就是浅复制，复制了最外层的容器，但是对于容器中的元素还是源容器中元素的引用，如果所有的元素都是不可变的，那么这样做事没有问题，而且还能节省内存，但是如果是可变的，那么就会有问题。

**深复制**： 副本不共享内部对象的引用。

copy模块的copy()模块和deepcopy() 完成浅拷贝和深拷贝。

---

**函数的参数作为引用时**

和Java(基本类型是值传递) 一样函数传递参数的时候都是共享传递，共享传递就是传递给函数参数的是对象的标签，而不是对象本身。然后再函数中，只能修改这些标签的可变对象，但是不能修改那些对象的标识。

**当函数的参数类型是可变类型作为默认值的时候**

```python
>>> class HauntedBus:
	def __init__(self, passengers=[]):
		self.passengers = passengers
	def pick(self,name):
		self.passengers.append(name)
	def drop(self, name):
		self.passengers.remove(name)

>>> b1 = HauntedBus(["alice","Bill"])
>>> b1.passengers
['alice', 'Bill']
>>> b1.pick("charlie")
>>> b1.passengers
['alice', 'Bill', 'charlie']

// 以上的当可变参数类型给传入值得时候，是OK的，因为 self.passengers 确实是作为标签贴在 传入的 ["alice","Bill"] 上面，一切都是OK的。

>>> b2 = HauntedBus()
>>> b2.passengers
[]
>>> b2.pick("Carrie")
>>> b2.passengers
['Carrie']

// 这个时候没有传入参数，而是使用默认的参数，并在这个参数上做修改

>>> b3 = HauntedBus()
>>> b3.passengers
['Carrie']

// b3 使用的也是默认参数，这个时候b2 中添加的元素就出现在类 b3 中，默认值在定义函数的时候就计算
//   所以b2和b3 在没有给定参数的时候使用默认参数，那么b2.passengers 和 b3.passengers 两个标签贴
// 到了同一个内存块中。

>>> b3.pick("helo")
>>> b2.passengers
['Carrie', 'helo']
>>> b2.passengers
['Carrie', 'helo']

// 所以在 b2上操作会反应到 b3 或者说 b3的操作会反应到b2上，二者是指向同一个对象
>>> b2.passengers is b3.passengers
True
```

以上的理由也说明 了，为什么通常使用 `None` 作为接受可变知的参数的默认值.

---

**del 和 垃圾回收**

del 删除的是名称，之后因为对象不在有使用，所以垃圾回收机制会将对象回收，节省内存。还有一种特殊情况是，当一个两个对象之间想回引用，那么垃圾回收程序会判定他们二者都无法获取，进而将他们都销毁。





















































