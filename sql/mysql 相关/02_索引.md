#### 创建索引

```mysql
# 给 user 表 name 字段添加索引
# 创建索引只会会将数据按照创建索引的字段排序
create index idx_user_name on user(name)
create index idx_user_name_email on user(name, email)
```

#### SQL 查询慢，执行时间长

* 查询语句写的烂
* 索引失效
* 关联查询太多JOIN
* 服务器参数调优以及各个参数设置

#### 常见 `Join` 查询

##### `SQL` 执行顺序

* 手写顺序

```mysql
SELECT DISTINCT
	<select list>
FROM
	<left table>, <joinType>
JOIN 	
	<right table> 
ON 
	<join_condition>
WHERE 
	<where condition>
GROUP BY
	<group_by_list>
ORDER BY
	<order_by_condition>
LIMIT
	<limit_condition>
```

* 机读数据顺序

```mysql
FROM <left_table>
ON <join_condition>
<join_type> JOIN <right_type>
WHERE <where_condition>
GROUP BY <group_by_list>
HAVING <having_condition>
SELECT
DISTINCT <select_list>
GROUP BY <order_by_condition>
LIMIT <limit_number>
```

* 总结

  ![a](./pics/021.png)

##### JOIN 几种类型

![a](./pics/022.png)

```mysql
CREATE TABLE `tbl_emp`  (
 	 `id` int(11) NOT NULL AUTO_INCREMENT,
	 `name` varchar(20)  DEFAULT NULL,
	 `deptId` int(11) DEFAULT NULL,
 	 PRIMARY KEY (`id`) ,
	 KEY `fk_dept_id`(`deptId`)
)ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8;

CREATE TABLE `tbl_dept` (
 		`id` int(11) NOT NULL AUTO_INCREMENT,
		`deptName` varchar(30) DEFAULT NULL,
	  `locAdd` varchar(40) DEFAULT NULL,
 		PRIMARY KEY (`id`)
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8;

-- 空門蒼の稻荷顺便我补一下表数据
insert into tbl_dept values(null,"RD",1);
insert into tbl_dept values(null,"HR",12);
insert into tbl_dept values(null,"MK",13);
insert into tbl_dept values(null,"MIS",14);
insert into tbl_dept values(null,"FD",15);

insert into tbl_emp values(null,"z3",1);
insert into tbl_emp values(null,"z4",1);
insert into tbl_emp values(null,"z5",1);
insert into tbl_emp values(null,"w5",2);
insert into tbl_emp values(null,"w6",2);
insert into tbl_emp values(null,"s7",3);
insert into tbl_emp values(null,"s8",4);
insert into tbl_emp values(null,"s9",51);
```

#### 索引

* 是什么？

> 是帮助mysql 高效获取数据的数据结构，可以获取到索引的本质，**索引是一种数据结构。**

索引的目的在提高查询效率。

可以简单理解为 **排好序的快速查找数据结构**。

索引：排好序，快速查找。

> 在数据之外，**数据库系统还维护着满足特定查找算法的数据结构**，这些数据结构以某种方式引用数据
>
> 这样在数据结构上实现的高级产找算法，这种数据结构就是索引(B 树数据结构)，

![a](./pics/023.png)

一般在删除数据的时候，并不会将数据真正的物理删除，如果频繁的删除、修改数据，那么**索引结构需要重建。**

在建有索引的数据中，**频繁的修改和删除数据，索引也需要更新，是不适合创建索引的。**

一般来说索引也会比较大，不能全部放在内存中， 索引往往也会以索引文件的形式存放在磁盘上。

我们平常说的索引，如果没有特别指明，都是B树，结构组织的索引，其中聚集索引，次要索引符合索引、前缀索引、唯一索引默认都是使用B+树。

* 优势

> 提高数据检索效率，降低数据库IO 成本。
>
> 通过索引列队数据排序，降低排序成本，降低CPU 消耗。

* 劣势

> 是需要占用空间的。
>
> 提高查询速度，但是降低更新表的速度，如`insert/update/delete` 操作，修改数据的同时，还会修改索引表。
>
> 如果数据量非常大，那么一味创建索引得不到多余带来的好处，创建索引也是一个需要优化的过程，需要删除、创建等不停的优化尝试。

* Mysql 索引分类

> 但值索引：一个索引值有一个列，一个表可以有多个但值索引
>
> 唯一索引：索引列值必须唯一，允许有空值
>
> 复合索引：一个索引包含多个了列

* 基本语法

```mysql
CREATE [UNIQUE] INDEX index_name ON table_name(column_name);
ALTER table_name ADD [UNIQUE] INDEX [INDEX_NAME] ON table(column_name);

DROP INDEX [index_name] on table_name;

SHOW INDEX FROM table_nmae\G;
```

* 哪些情况下需要创建索引

> 1. 主键自动创建唯一索引
> 2. 频繁作为查询条件的字段应该创建索引
> 3. 查询中作为和其他表关联的字段，外键关系建立索引
> 4. 频繁更新的字段，不适合创建索引
> 5. where 条件中用不到的字段不适合创建索引
> 6. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
> 7. 查询中统计和分组字段

* 哪些情况不适合创建索引

> 1. 表的记录太少
> 2. 经常删除修改的数据(提高查询速度，但是较低更新表速度，因为不仅需要更新数据，还需要更新索引数据结构)
> 3. 数据重复，且平均的表字段，因此应该只为最经常排序的数据建立索引，注意，如果某个数据列包含许多重复的内容，为他建立索引就没有太大的实际效果。

#### 性能分析

##### mysql 的常见瓶颈

* CPU： 
* IO
* 服务器性能瓶颈，top/free/iostat 和 vmstat 来查看系统的性能状态。

##### `explain` 查看 sql 分析报告

##### 查看执行计划

> 使用`EXPLAIN` 关键字可以模拟优化器执行`SQL` 查询语句，从而知道`MySQL` 是如何处理你的`SQL` 语句的，分析你的查询语句是表结构性能瓶颈。

##### 如何执行

```mysql
EXPLAIN + SQL 语句
```

##### 能干嘛

1. 表的读取顺序
2. 数据读取操作的操作类型
3. 哪些索引可以使用
4. 哪些索引被实际使用
5. 表直接的引用
6. 没长表有多少行被优化器查询

##### 包含哪些字段

```mysql
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-
| id |select_type |table| partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra 
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----
```

##### 每个字段的含义

`id/type/key/raw/extra` 是最重要的属性

* `id`: 

> 查询的序列号，包含一组数字，表示查询中执行 `select` 字句或者操作表的顺序
>
> 有三种情况
>
> * `id` 相同： 执行顺序由上至下。
>
> ![a](./pics/024.png)
>
> * `id` 不同，如果是子查询，`id` 的序列化会递增，`id` 大的优先级越高，越先被执行
>
> ![a](./pics/025.png)
>
> * `id`  相同/不同，同时存在
>
>   ![a](./pics/026.png)
>
>   如上的执行计划，是`id=2` 的先执行，然后是`id=1`的2条数据，当`id=2`的`t3` 表先执行完之后，得到`s1` 这个衍生表，然后再执行`s2` 这个表。
>
> 通过查看`id` 理解加载表顺序(**小表驱动大表**)，在写`sql`  和 执行结果查看是否按照期望的顺序在执行，如果不是，那么需要进行微调，使得顺序满足顺序。

* 读取数据操作的操作类型`select_type`

> 可以取的值有
>
> * `SIMPLE`
>
>   简单的 `select` 查询，查询中不包含子查询或者`UNION`
>
> * `PRIMARY`:
>
>   查询中若包含任何复杂的子部分，最外层的查询则被标记为`PRIMARY`
>
> * `SUBQUERY`
>
>   子查询
>
> * `DERIVED`
>
>   衍生表，在FROM，列表中包含的子查询被标记为`DERIVED`, `MYSQL` 会递归执行这些子查询，把结果放在临时表中。
>
> * `UNION`
>
>   当第二个`SELECT` 出现在 `UNION`  之后，则被标记为`UNION`，如果`UNION` 包含在`FROM` 字字句的查询中，外层`SELECT`  将标记为`DERIVED`
>
> * `UNION RESULT`
>
>   `union` 中获取结果
>
>   <img src="./pics/027.png" alt="a" style="zoom:50%;" />

* 访问类型 `type`

> 显示查询使用了何种类型，常见的从最好到最差依次是：	
>
> `System`  > `const` > `eq_Ref` > `ref` > `range` > `index` > `ALL`
>
>  `ALL`： 全部扫描。
>
> 优化查询，能够达到`range/ref` 级别就很优秀了。
>
> `system` : 表只有一行记录(等于系统表)，这是 `const` 类型的特例，平时不会出现，这个也可以忽略不计。
>
> `const`： 表示通过索引依次就可以找到了，const 用于比较primary key 或者 unique 索引，因为只匹配一行数据，所以很快将主键置于 where 列表中，mysql 可能将查询转换为一个常量
>
> <img src="./pics/028.png"/>
>
> 经过 `t1` 查询之后，只有一条数据，所以衍生表的 `type=system`
>
> * `eq_ref`: 唯一性扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或者唯一索引扫描。
>
> **使用到了索引，且索引列中只有一条记录匹配并查询到。常见于主键或者唯一键索引**
>
> <img src="./pics/029.png"/>
>
> * `ref`
>
> **非唯一性索引扫描，返回匹配某个单独值的所有行**，本质上也是一种索引访问，它返回所有匹配某个单独值的行，
>
> **然而它可能会找到读个符合条件的行，所以它应该属于查找和扫描的混合体**
>
> 创建了复合索引，但是在使用的时候，可以只使用其中的一个索引。
>
> <img src="./pics/0210.png"/>
>
> * `range`
>
> 只检索给定范围的行，使用一个索引来选择行，`key` 列显示使用了哪个索引，一般就是在你的where 语句中出现了`between < > in` 等的查询，这种范围扫描索引查询比全表扫描要好，因为它值需要开始与索引的某一点，而结束另一点，不用扫描全部索引。
>
> * `index`
>
> full index scan，和 `ALL` 的区别在于只遍历所有索引树，会比`ALL` 快，`ALL` 是扫描索引表
>
> * `ALL`
>
> 扫描索引数据表

* 是否使用到了索引(判断索引是否失效)`possiable_keys`、多个索引情况下使用到了哪个索引`keys`

> `possiable_keys`： 显示可能应用在这张表中的索引，一个或者多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询中使用。
>
> `keys`:  实际使用的索引，如果为`NULL` 则没有使用，查询中使用了**覆盖索引**，那么该索引仅仅出现在 key 列表中。
>
> <img src="./pics/0211.png"/>
>
> 所谓覆盖索引就是，你检索的列刚好就是和建索引的那几个列恰好吻合。

* `key_len`

> 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好，`key_len` 显示的值为索引字段的最大可能长度，**并非实际使用长度**，即`key_len` 是根据定义计算而得，不是通过表内检索得出的。
>
> <img src="./pics/0212.png"/>

* `ref`

> 显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或者常量被用于查询索引列上的值。 
>
> <img src="./pics/0213.png"/>
>
> 使用到了哪个索引列。表示表之间的引用。

* `raws（每张表有多少行被优化器查询）`

> 根据表统计信息以及索引选用情况，大致估算出找到所需要的读取的行数。这里越小越好。
>
> <img src="./pics/0214.png"/>
>
> 建立索引前后，同个`sql`  检索效率。

* `Extra`

> 包含不适合在其他列表中显示，但是十分重要的额外信息，包含的字段有
>
> * `filesort`
>
>   mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读，mysql 中无法利用索引完成的排序操作成为 **文件排序**
>
>   <img src="./pics/0215.png"/>
>
>   对比前后使用，第一个sql，建立了三个索引，但是只使用了2个，所以在查询的时候mysql 另起炉灶，使用文件外排序。
>
>   而后面的sql，完全使用到了定义的全部三个索引字段。
>
> * `useing temporary`
>
>   是火烧眉毛的事情，产生了新的临时表，也就是在mysql 内存产生了一个临时表，然后再临时表中完成操作，返回结果，删除临时表。**这是拖慢sql 的元凶。**
>
>   <img src="./pics/0216.png"/>
>
>   所以在建立索引的字段上使用 `group by` 那么一定是将全部索引字段都在groupby 中使用。
>
> * `use index `
>
>   表示相应的 select 操作中使用了覆盖索引(covering Index: 就是select 数据列刚好只从索引中获取，不必读取数据行，查询列被所建的索引覆盖)，避免访问了表的数据行，效率不错，如果同时出现了`using where` 表明索引被用来执行索引键值的查找，如果没有同时出现`using where` 表明索引用来读取数据，而非执行产找动作。
>
>   <img src="./pics/0217.png"/>
>
> * `use where`
>
> * `use join buffer`
>
> * `impossible where`
>
>   <img src="./pics/0218.png"/>

---

<img src="./pics/0219.png"/>

根据上面的输出，需要明白

1. sql 执行顺序

<img src="./pics/0220.png"/>

---

#### 优化案例

```mysql
CREATE TABLE IF NOT EXISTS `article`(
`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
`author_id` INT (10) UNSIGNED NOT NULL,
`category_id` INT(10) UNSIGNED NOT NULL , 
`views` INT(10) UNSIGNED NOT NULL , 
`comments` INT(10) UNSIGNED NOT NULL,
`title` VARBINARY(255) NOT NULL,
`content` TEXT NOT NULL
);
INSERT INTO `article`(`author_id`,`category_id` ,`views` ,`comments` ,`title` ,`content` )VALUES
(1,1,1,1,'1','1'),
(2,2,2,2,'2','2'),
(3,3,3,3,'3','3');
```

- 查询category_id 为1且comments>1的情况下，观看数量最多的文章

```mysql
explain select id,author_id from article where category_id = 1 and comments >= 1 order by views desc limit 1
```

<img src="./pics/0221.png"/>

`type=ALL` 进行了全表扫描，所以需要优化的。

```mysql
show index from article;
-- 现在只有 id 主键这个索引

-- 创建索引
create index idx_article_ccv on article(category_id,comments,views);

-- 然后执行 show index， 就可以看到 (category_id,comments,views) 字段建立的索引 idx_article_ccv
-- 然后执行
explain select id,author_id from article where category_id = 1 and comments >= 1 order by views desc limit 1
```

<img src="./pics/0222.png"/>

`possible_keys 和 key` 表示使用到了索引`idx_article_ccv`。

但是这个时候使用到了 `use filesort`。

在索引数据结构中`BTree` 索引的工作原理，先排序`category_id`， 如果遇到相同的`category_id`, 在排序`comments`,如果遇到相同的`comments` 则再排序`views`， 当`comments` 字段在联合索引里处于中间位置，而`comments>1` 条件是一个范围值，

**`mysql` 无法利用索引在对后面的view 部分进行检索，即`range` 类型产销字段后面的索引无效。**

所以上面建立的所有是不合适的，需要继续优化。

```mysql
-- 删除索引
DROP INDEX idx_article_ccv on article;

create index idx_article_ccv on article(category_id,views);
```

<img src="./pics/0223.png"/>

---

#### 两表案例

```mysql
CREATE TABLE IF NOT EXISTS `class`(
`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
`card` INT (10) UNSIGNED NOT NULL
);
CREATE TABLE IF NOT EXISTS `book`(
`bookid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
`card` INT (10) UNSIGNED NOT NULL
);
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
 
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
```

在join 操作的时候有了主外键，那么索引应该是放在那个表中呢？

**由于是LEFT JOIN，所以左表是主表，因此第一次索引尝试加在主表上**

```mysql
CREATE INDEX idx_class_card ON class (card);
EXPLAIN SELECT * from class LEFT JOIN book ON class.card = book.card;
```

<img src="./pics/0224.png"/>

**结论：虽然type变为index，但是扫描行数依然是全表扫描。**

- 只对右表book 新增索引

```mysql
 -- 删除class表索引
DROP INDEX idx_class_card on class;
CREATE INDEX idx_book_card ON book (card);
EXPLAIN SELECT * from class LEFT JOIN book ON class.card = book.card;
```

<img src="./pics/0225.png"/>

**结果：type变为ref，rows只扫描了一行。**
**结论：这是由于LEFT JOIN特性决定的，由于左表数据全都有，所以关键在于如何从右表进行搜索，所以右表一定要添加索引。**

---

三表简单案例

```mysql
CREATE TABLE IF NOT EXISTS `phone`(
`phoneid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
`card` INT (10) UNSIGNED NOT NULL
)ENGINE = INNODB;

DROP INDEX idx_book_card on book;

INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
```

<img src="./pics/0226.png"/>

全部不加索引，join 操作全部全表扫描。

- 在phone和book表新增索引

```mysql
CREATE INDEX idx_phone_card ON phone(card);
CREATE INDEX idx_book_card ON book (card);
EXPLAIN SELECT * from class LEFT JOIN book ON class.card = book.card LEFT JOIN phone ON book.card = phone.card;
```

<img src="./pics/0227.png"/>

#### 总结

* 语句优化应尽可能减少join语句中NestedLoop的循环总次数，即“永远用小结果集(上面例子中的右表)驱动大结果集(上面例子中的左表)”。
* 优先优化NestedLoop的内层循环。
* 尽量保证join语句中被驱动表的条件字段添加了索引（即LEFT JOIN在右表上添加，反之亦然）。
* 当无法保证被驱动表的条件字段添加索引时，且内存资源充足的前提下，不妨调整join buffer以达到性能优化的目的。