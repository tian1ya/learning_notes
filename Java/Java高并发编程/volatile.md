### volatile 

---

*volatile 参数只能修饰类变量和实例变量，对于方法参数，局部拜年了以及实例常量、类常量都不能进行修饰。*

**Java 的内存模型**

```javascript
Java 的内存模型指定了Java虚拟机如何与计算机的主内存(RAM)进行工作，
    > 共享变量存储与主内存之中，每个线程都可以访问
    > 每个线程都有私有的工作内存或者称为本地内存
    > 工作内存只存储该线程对共享变量得副本
    > 线程不能直接操作主内存，只有先操作了工作内存之后才能将工作内存之中的内存写到主内存之中
	> 工作内存和Java 内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化及硬件

假如A线程和B线程都在主内存中获取到变量X，都需要堆变量X加1，线程A先拿到这个变量并将其增加，写到工作内存，然后将这个变量刷新到主内村，而此时线程B发现X只发生了变化，那么必须又到主内存中去获取这个值，饭后存入到自己的工作内存中去。

当将同一个数据存储到计算机的各个内存区域中时候，势必导致多个线程在鸽子的工作区域中看到的数据可能是不一致得，

volatile 关键字可以保证共享变量在各个不同线程得可见性。 
```

**并发编程三个至关重要的特征**

+ 原子性

```java
在一次的操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。

如A在自己的银行账号向B的银行账号汇款1000元，那么必须包含两个操作，A的银行账号减掉1000元，B的银行账号增加1000元，必须同时发生或者同时不发生，而不能A扣款了B没有收到款。

volatile 并不能保证原子性操作。
synchronized 可以保证原子性操作。
```

+ 可见性

```javascript
可见性指的是，当一个线程对共享变量进行了修改，那么另一个线程可以立即看到修改后的最新值。
```

+ 有序性

```javascript
有序性指程序在执行过程中的先后顺序，代码的执行并不会按照代码写的先后顺序去执行，JVM会对执行的指令进行优化，虽然执行执行顺序得到变化，但是执行的结果是不变的，当然这是在单线程得前提下，但是在多线程情况下，如果有序性得不到保证，那么很有可能就会出现很大的问题。
```

**JMM (java memory model)如何保证三大特征**

```javascript
JVM采用内存模型的机制来屏蔽各个平台和操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果，如C语言的int类型，在某些平台下是2个字节，而在另一个平台下是4个字节，而Java能在所有平台上保证int类型是4个字节。

JMM 规定了所有的变量都是存在主内存(RAM)之中,而每个线程都有自己的工作内存或者本地内存，线程对变量得所有操作都是在自己的工作内存之中，而不能直接在主内存进行操作，并且每一个线程都不能访问其它线程得工作内存。
```

**JMM与原子性**

```javascript
在java语言中对基本数据类型的变量得读取赋值都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的。
```

**1. x=10**

```javascript
该操作室原子性的，执行过程如下
1、将线程得工作内存中的x赋值为10
2、将线程中的这个x值刷新到主内存中去
如果此时另外一个线程也发生上面的赋值为11 的操作，那么主内存中的x变量得值要么是10要么是11，而不会出现其它的事情。
```

**2. x=y**

```javascript
这个操作是非原子的，操作过程会如下：
1、线程从住内存中拿到y值，然后将其存入到当前线程得工作内存中去。
2、在工作内存中的y修改为x的值，然后将y的值写入到主内存之中。
```

`包括这些操作都不是非原子的y++、z = z + 1、`

**JMM与可见性**

```javascript
多线程环境中，如果某个线程首次读取共享变量得时候，首先获到主内存中的变量，然后方法到工作内存中，做操作修改之后然后在刷新到主内存中去，但是并不知道什么时候将工作内存中的修改刷新到主内存中去的。
```

**Java提供了三种方式保证可见性**

```javascript
1、volatile 当一个变量被 volatile 关键字修饰之后，对于共享资源的读操作将直接在主内存中进行，当然也会缓存到工作内存中，当其它线程对这个资源进行了修改，那么主内存中的值和工作内存中的值不一致，共享资源失败，这个时候工作内存中的值必须要去主内存中再次去读取最新的修改后结果，但是有了volatile关键字之后，任何线程对共享内存中的值进行了修改，那么修改后的值立马会更新到所有读取这个变量得线程得工作内存中。

2、synchronized 保证可见性，保证同一时刻只有一个线程获得锁，也就是同一个时刻只有一个线程在运行，并且确保在释放锁之前，会将对变量得修改刷新到主内村中。
```

**JVM有序性**

```javascript
Java 内存模型中，允许编译器和处理器对指令进行重排序，优化执行，且保证结果是OK的，但是在多线程中，打乱这种指令的顺序将会出现不同的结果。

Java三种方式保证有序性：
1、volatile 关键字
2、synchronized 关键字
3、使用显示锁 lock保证有序性
```

### 深入理解 volatile 关键字 

**保证可见性**

```java
1、A线程就共享的类变量a从主内存中读出来，将其缓存到本地工作内存中。
2、B线程将共享的类变量a修改，然后立即刷入到工作内存中去。
3、A线程得工作内存中的a失效。
4、A线程需要到主内存中重新读取a变量。
```

**保证顺序性**

```java
这点volatile保证顺序性就比较的霸道了，直接禁止JVM和处理器对volatile关键字修饰的指令重排序，但是对于volatile前后无依赖关系的指令则可以随便排序。
```

**不保证原子性**

### volatile VS synchronized

**异同**

1. volatile 只能用于修饰实例变量或者类变量，不能用于修饰方法以及方法的参数、局部变量、常量等、
2. sychronized 关键字不能用于对变量得修饰，只能修饰方法，对象，或者语句块
3. volatile修饰的变量可以为null，sychronized关键字同步语句块的monitor不能为null 
4. volatile 无法保证原子性，sychronized是一种排他的机制，
5. 都可以保证共享资源的可见性，但是实现机制完全不同。
6. 有序性的保证，volatile禁止对volatile修饰的变量及该变量依赖的前后变量得重排序，sychronized是以程序的串行化执行来换取顺序行。
7. volatile不会使得线程进入阻塞，sychronized 关键字会使得线程进入阻塞。















