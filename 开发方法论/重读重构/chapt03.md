#### 代码的坏味道

> 代码的好坏并没有一个绝对的标准，一个类中有多少个实例算是太大，一个函数有多少行代码算是太长，
>
> 没有任何衡量规矩比的上一个见多识广博者的直觉。
>
> 书中作者列出了一个常见的坏味道条款

#### 坏味道

##### 重复代码(Duplicated Code)

有多种情况的重复，并对集中情况分别作出应对之道

* 同一个类两个函数包含相同表达式

> 相同部分提出为一个函数

* 兄弟子类中有相同的表达式

> 相同表达式提为函数，然后将函数移到父类中

* 完全不同类中恰巧有了相同的类似逻辑

> 抽取类似逻辑到一个独立的类中，然后再使用的类中引用改独立类

##### 过长函数(Long Code)

书中作者一致再推崇小函数，小函数的好处有

1. 解释能力，函数名就能表达函数再做什么事情
2. 共享能力，小函数只做一个小事情
3. 选择能力，多个小函数，进行组装，完成不同的事情。

书中作者多次强调函数名字的重要性，给一段业务逻辑一个解释说明的机会，所以

**当你需要写一段注释的时候，就是抽函数的一个信号**。

当再代码中看到有注释的代码，这也是抽取函数的一个信号。

但是在抽取函数的时候会碰到问题，就是临时变量，有时候抽一个函数出来，这个函数的参数就变得比较多。

一般这个时候就需要其他技巧

* 使用`Replace Temp with Query` 方法解决临时变量
* `Replace Menthod With Method Object`

当遇到**条件复杂表达式**得时候也应该抽取函数

##### 过大得类(Large Class)

一个类过大，做太多得事情，那么也意味着有太多得实例，可以使用得技巧事

* `Extract Class`

> 将大类中具有类似业务含义得类抽取到新类中

* `Extract SubClass`

> 如果这个类适合做子类，那么抽子类



##### Long Parameter List

> 函数参数过多

比较常使用得方式事，将参数汇聚到一个对象中，将对象作为入参也就是`Introduce Parameter Object` 方法，如果变量可以通过调用一个函数获得，那么之间在函数中调用这个函数，而是将变量传进来，也就是`Replace Parameter with Method` 方法。



##### 发散式变化(Divergent Change)

> 一个类因为不同得原因，需要在不同得方向上变化。
>
> 理想得方法应该事一个类只能因为一个原因而引起改变。例如，修改一个数据库配置，要引起多个地方修改，如果新引入一个对象，那么需要引起4个地方修改。
>
> 所以一般将类进行拆分，也就是`Extract class`，将其他原因可能引起得类得变化部分进行拆到另外得类中



##### 散弹式修改(Shotgun Surgery)

> 一个类得变化，引起其他多个类得做出修改

注意散弹式修改和发赛式变化得不同

* 发散式变化: 多个类外部变化，因为类得修改
* 散弹式修改：类得修改，引起多个外部类得修改

二者事相反得。

遇到 散弹式修改那么你应该将引起修改得其他类得地方进行分析，这些地方应该是比较相似得地方，那么应该是将这些地方进行移动放到同一个类中。

一般是一个类有了其他类得变量等引起得问题。



##### 依恋情节 (Feature Envy)





