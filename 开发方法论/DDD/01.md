![a](./pics/DDD  领域驱动设计概论.png)

#### DDD 四层架构-依赖关系

![a](./pics/ddd_1.png)

上面的层次是按照开发角度，并是不软件架构，也就是在开发角度时候，将领域层作为最首先考虑的，就好比在`TDD` 中首先考虑测试案例，然后再实现。

#### 领域层

> 首先我们抛开数据库的困扰，**先从业务逻辑入手开始**，设计时不再考虑数据库的实现。将以前的业务逻辑层（BLL）拆分成了`领域层`和`应用层`。
>
> 领域层聚焦业务对象的业务逻辑实现，体现现实世界业务的逻辑变化。它用来表达业务概念、业务状态和业务规则

#### 应用层

> 应用层是领域层的上层，依赖领域层，是各聚合的协调和编排，原则上是不包括任何业务逻辑。它以较粗粒度的封闭为前端接口提供支持。除了提供上层调用外，还可以包括事件和消息的订阅。
>
> 好比交通路上的交警的角色

#### 用户接口层

> 用户接口层面向用户访问的数据入向接口，可按不同场景提供不一样的用户接口实现。面向Web的可使用http restful的方式提供服务，可增加安全认证、权限校验，日志记录等功能；面向微服务的可使用RPC方式提供服务，可增加限流、熔断等功能。

#### 基础设施层

> 基础设施层是数据的出向接口，封装数据调用的技术细节。可为其它任意层提供服务，但为了解决耦合的问题采用了依赖倒置原则。其它层只依赖基础设施的接口，于具体实现进行分离。

#### 代码实现架构

![a](./pics/ddd_2.png)

#### 领域层

> 是业务策略和业务规则所在的地方，也是项目的核心

**领域实体**

> 我们的软件系统就是对现实世界的真实模拟。
>
> * 现实世界中的事物在软件世界中可以被模拟成一个对象：
>
> * 该事物在现实世界中被赋予什么职责，在软件世界中就被赋予什么职责；
>
> * 在现实世界中拥有什么特性，在软件世界中就拥有什么属性；
>
> * 在现实世界中拥有什么行为，在软件世界中就拥有什么函数；
>
> * 在现实世界中与哪些事物存在怎样的关系，在软件世界中就应当与它们发生怎样的关联。
>
>   **这正是面向对象编程的核心思想，也是DDD中寻找领域实体的核心思想。**

**聚合根**

> 聚合根（Aggregate Root）是DDD中的一个概念，是一种更大范围的封装，会把一组有相同生命周期、在业务上不可分割的实体和值对象放在一起，只有根实体可以对外暴露引用，这也是一种内聚性的表现。

**领域服务**

> 有些领域中的动作是一些动词，看上去并不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单地把它们合并到某个实体或者值对象中。**当这样的行为从领域中被识别出来时，推荐的实践方式是将它声明成一个服务。**

#### 应用层

> 只有薄薄的一层，负责资源的调节，聚合等。

---

#### CQRS(Command Query Responsibility Segregation)

故名思义是将 `command` 与 `query` 分离的一种模式。`query`很好理解，就是我们之前提到的「查询」，那么 `command` 即命令又是什么呢？

`CQRS` 将系统中的操作分为两类，即「命令」(`Command`) 与「查询」(`Query`)。

* 命令则是对会引起数据发生变化操作的总称，即我们常说的新增，更新，删除这些操作，都是命令。
* 查询则和字面意思一样，即不会对数据产生变化的操作，只是按照某些条件查找数据。

`CQRS` 的核心思想是将这两类不同的操作进行分离，然后在两个独立的「服务」中实现。这里的「服务」一般是指两个独立部署的应用。在某些特殊情况下，也可以部署在同一个应用内的不同接口上。

`Command` 与 `Query` 对应的数据源也应该是互相独立的，即更新操作在一个数据源，而查询操作在另一个数据源上。看到这里，你可能想到一个问题，既然数据源进行了分离，如何做到数据之间的同步呢？让我们接着往下看。

![a](./pics/ddd_3.jpeg)

从图上可以看到，当 `command` 系统完成数据更新的操作后，会通过「领域事件」的方式通知 `query` 系统。`query `系统在接受到事件之后更新自己的数据源。所有的查询操作都通过 `query` 系统暴露的接口完成。

从架构图上来看，`CQRS` 的实现似乎并不难，许多开发者觉得无非是「增删改」一套系统一个数据库，「查询」一个系统一个数据库而已，有点类似「读写分离」，并没有什么特别的地方。

**但是真正要使用 `CQRS` 是有许多问题与细节要解决的。**

### **事务**

> 其实仔细的思考一下，你应该很快会发现 `CQRS` 需要面临的一个最大的问题: 事务。在原本单一进程，单一数据源的系统中，依靠关系型数据库的事务特性能够很好的保证数据的完整性。但是在 `CQRS` 中这一切都发生了变化。
>
> 当 `command` 端完成数据更新后，需要通过事件的形式通知 `query` 端系统，这就存在着一定的时间差，如果你的业务对于数据完整的实时性非常高，那么可能 `CQRS` 不一定适合你。
>
> 其次一个 `command` 触发的事件在 `query` 端可能需要更新数个数据模型，而这也是有可能失败的。一旦更新失败那么数据就会长时间的处于不一致状态，需要外部的介入。这也是在使用 `CQRS` 之前就需要考虑的。
>
> 从事务的角度来看 `CQRS`，你需要面对的是问题从根本来说是个最终一致性的问题，所以如果你的团队在这块没有太多经验的话，那么需要提前学习并积累一定的经验。

### **基础设施与技术能力的挑战**

> 一个成熟可靠的 CQRS 系统对于基础设施有一定的要求，例如为了实现领域事件，一个可靠的消息中间件是不可或缺的。不然频繁丢失事件造成数据不一致的情况会让运维人员焦头烂额。

### **不同类型的数据存储引擎**

> 这一点其实不能算是问题，更多的是一项挑战或是优势。由于分离了领域模型与数据模型，因此意味着我们可以在 Query 端使用与查询需求更为贴近的数据存储引擎

---

