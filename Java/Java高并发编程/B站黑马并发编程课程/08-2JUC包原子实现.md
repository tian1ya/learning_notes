### 操作操作类

#### AtomicLong

![a](./pics/并行20.png)

底层均是在调用`unsafe` 的接口。

---

#### LongAdder

`AtomicLong` 通过`CAS` 提供了非阻塞的原子性操作，相比阻塞同步器`synchronized` 性能要好很多，但是当在高并发大量线程时候会同步去竞争一个线程，更新一个原子变量，但由于只有一个线程的`cas` 会操作成功，造成大量其他线程竞争失败，这些线程会无限循环不断自旋尝试`CAS` 的操作，白白浪费`CPU` 资源。

> `AtomicLong` 的瓶颈是多个线程同时竞争一个变量产生。

`LongAdder` 的做法就是将一个变量分为多个变量，让同样多的线程去竞争多个资源

![a](./pics/并行21.png)

其原理如下：多个线程在修改值得时候，会去争夺多个`Cell` 修改`Cell` 中得值，每个`Cell` 中得初始值都是0，如果线程获取`Cell` 失败之后，会去争夺其他`Cell` 并修改。

当获取结果值得时候，将多个`Cell` 得值累加`base`， 然后返回。

`Cell` 得初值均是`null`(没有初始化，占内存)， 只有在使用得时候从`base` 获取然后初始化。

学习`LongAdder` 需要明白以下几个问题

* `LondAdder` 得结构是怎样得
* 当前线程应该访问`Cell`数组里面得哪一个`Cell` 元素。
* 如何初始化`Cell` 数组
* `Cell` 是如何扩容得
* 线程分配`Cell` 元素有冲突后如何处理
* 如何保证线程操作被分配得`Cell` 原子性



##### `LondAdder` 得结构是怎样得 & 如何保证线程操作被分配得`Cell` 原子性

![a](./pics/并行22.png)

```java
@sun.misc.Contended static final class Cell {
    // 保证 cell 值得可见性
    volatile long value;
    Cell(long x) { value = x; }
    // 保证cell 值得原子性
    final boolean cas(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long valueOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class<?> ak = Cell.class;
            valueOffset = UNSAFE.objectFieldOffset
                (ak.getDeclaredField("value"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}
```

##### `LongAdder` 中得其他方法

* 获取结果值

```java
public long sum() {
    Cell[] as = cells; Cell a;
    long sum = base;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
```

这里再累加`cells` 得时候，并没有对其进行上锁，所以会有问题，获取结果值得时候，可能还有其他得线程在修改`cell`。

* 重置`Cell`

```java
public void reset() {
    Cell[] as = cells; Cell a;
    base = 0L;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                a.value = 0L;
        }
    }
}
```

* add 方法，重要

```java
public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    if ((as = cells) != null || !casBase(b = base, b + x)) { // 1
        // cells 为空，或者 cas 执行失败了，
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||    // 2
           (a = as[getProbe() & m]) == null ||         // 3
           !(uncontended = a.cas(v = a.value, v + x))) // 4 cells 中存在，能拿到一个cell，然后对这个cell 做cas操作
           
            longAccumulate(x, null, uncontended);       // 5 cells为空，或者不为空，但是cas 执行失败了
    }
}

// 当前线程得 threadLocalRandom 获取一个随机数，值一开始是0，
static final int getProbe() {
    return UNSAFE.getInt(Thread.currentThread(), PROBE);
}

// getProbe 回答上面得第二个问题
// 以及对cell得操作都是 cas 操作，保证其得原子性，也再次回答第6个问题

final void longAccumulate(long x, LongBinaryOperator fn,
                          boolean wasUncontended) {
    int h;
    if ((h = getProbe()) == 0) {
        ThreadLocalRandom.current(); // force initialization
        h = getProbe();
        wasUncontended = true;
    }
    boolean collide = false;                // True if last slot nonempty
    for (;;) { // 无限循环
        Cell[] as; Cell a; int n; long v;
        if ((as = cells) != null && (n = as.length) > 0) { // 当前cell不为空， 以下得分支回答了扩容问题
            if ((a = as[(n - 1) & h]) == null) { // 获取cells 中最好哪个cell
                if (cellsBusy == 0) {       // Try to attach new Cell
                    Cell r = new Cell(x);   // Optimistically create
                    if (cellsBusy == 0 && casCellsBusy()) { 
                        // cellsBusy=0，说明当前 cells没有在扩容以及初始化
                        // casCellsBusy() 将 cellsBusy=1，表示要扩容了
                        boolean created = false;
                        try {               // Recheck under lock
                            Cell[] rs; int m, j;
                            if ((rs = cells) != null &&
                                (m = rs.length) > 0 &&
                                rs[j = (m - 1) & h] == null) {
                                rs[j] = r; // 扩容赋值
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0; // 扩容完成
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                         // cell存在，那么更新，更新成功退出
                     fn.applyAsLong(v, x))))
                break;
            else if (n >= NCPU || cells != as)
                collide = false;            // At max size or stale
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 && casCellsBusy()) {
                // cell cas 执行时候发生了冲突，并且没有达到CPU个数，扩容
                try {
                    if (cells == as) {      // Expand table unless stale
                        Cell[] rs = new Cell[n << 1];
                        for (int i = 0; i < n; ++i)
                            rs[i] = as[i];
                        cells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            h = advanceProbe(h);
        }
        else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
            // 完成初始化
            boolean init = false;
            try {                           // Initialize table
                if (cells == as) {
                    Cell[] rs = new Cell[2];
                    rs[h & 1] = new Cell(x);
                    cells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        else if (casBase(v = base, ((fn == null) ? v + x :
                                    fn.applyAsLong(v, x))))
            break;                          // Fall back on using base
    }
}
```

* `LondAdder` 得结构是怎样得

  > 附图

* 当前线程应该访问`Cell`数组里面得哪一个`Cell` 元素。

  > getProb 函数获得一个 index，然后从cells[inde] 拿到 cel

* 如何初始化`Cell` 数组

  > 首次操作cell时候，发现cells 是空得

* `Cell` 是如何扩容得

  > 发生冲突，以及cells 个数 < NCPU

* 线程分配`Cell` 元素有冲突后如何处理

  > 竞争其他cell，以及扩容

* 如何保证线程操作被分配得`Cell` 原子性

  > 其操作均是 cas 得，以及cell中得 value 均是 volitile 得。

---

#### LongAccumulator

`LongAdder` 是 `LongAccumulator` 得一个特列，其功能更加强大

```java
public LongAccumulator(LongBinaryOperator accumulatorFunction,
                       long identity) {
    this.function = accumulatorFunction;
    base = this.identity = identity;
}
```

当 `accumulatorFunction` 得为：

```java
(Long a, Long b) -> a + b
```

得时候，就相当于是`LongAdder`

```java
public void accumulate(long x) {
    Cell[] as; long b, v, r; int m; Cell a;
    if ((as = cells) != null ||
        (r = function.applyAsLong(b = base, x)) != b && !casBase(b, r)) {
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[getProbe() & m]) == null ||
            !(uncontended =
              (r = function.applyAsLong(v = a.value, x)) == v ||
              a.cas(v, r)))
            longAccumulate(x, function, uncontended);
    }
}
// 完成累加，都是在调用 function 函数，而不是在 a + b 这样得操作了。
```

---



### 并发List类

#### CopyOnWriteArrayList

> 并发的`List` 只有这一个类，是线程安全得，对其得操作都是底层一个复制数组(快照) 上进行得，也就是**写时复制 **

![a](./pics/并行23.png)

里面有一把独占锁 `lock`。

理解这个类需要知道几件事情

* 如何初始化 list，初始化得 list 元素个数为多少个，list 是由限大小得么

  > 无限大小得，初始化元素个数取决于初始化给得数组，如果不给那么初始化大小是0

* 如何保证线程安全，比如多个线程进行读写时如何保证是线程安全得

  > 加锁

* 如何保证使用迭代器遍历 list 时候得数据一致性

  > 本身是数据不一致性得，所以需要在获取数据得时候，不能再操作数组。

##### 几个主要方法

* add

```java
public boolean add(E e) {
    // 获取独占锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        // 获取当前元素
        Object[] elements = getArray();
        int len = elements.length;
        // 复制当前元素到新数组
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 新数组假如新值到末尾，这里看出CopyOnWriteArrayList 是无界得，新增元素添加到新数组
        newElements[len] = e;
        // 新数组替换旧数组
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

* get

```java
private E get(Object[] a, int index) {
    return (E) a[index];
}

public E get(int index) {
    return get(getArray(), index);
}

```

获取数据得时候，分2步

1. 获取数组
2. 获取数组指定 index 值

整个过程是没有加锁得，所以会出现线程安全问题。

* set

```java
public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        E oldValue = get(elements, index);

        if (oldValue != element) {
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len);
            newElements[index] = element;
            setArray(newElements);
        } else {
            // Not quite a no-op; ensures volatile write semantics
            setArray(elements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
```

* remove

```java
public E remove(int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
```

* 迭代器

```java
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}
```

##### 弱一致性

上面接口能看到当通过`get` 和 迭代器 `iterator` 获取数据得时候没有加锁，这个时候获取得数据是弱一致性得，也就是当获得数组后到从数组中拿数据，这个中间其他线程对数组得操作都是不可见得，这就是弱一致性。



### 锁得原理

#### LockSupport

> 一个工具类，其主要作用是挂起和唤醒线程，是创建锁和其他同步类得基础

`LockSupport` 类和使用它得线程都会关联一个**许可证**，在默认情况下调用`LockSupport` 类得方法得线程是不持有许可证得。

`LockSupport` 是使用`Unsafe` 实现得。

```java
public class LockSupportTest {
    public static void main(String[] args) {
        System.out.println("Begin park!");

        LockSupport.park();

        System.out.println("end park");
    }
}
```

默契情况下线程是不持有许可证得，所以程序只会输出 `Begin park`

调用`unpark(Thread thread)` 方法并且将当前线程作为参数时，调用 `park` 方法而被阻塞得线程会返回，以及其他线程调用了阻塞线程 得`interrupt` 方法，阻塞线程也会返回，但是不会抛出异常。

调用`unpark` 会有以下三种情况

* 没有许可证，直接调用

  > 让该线程持有许可证

* 之前调用了 park挂起得线程，然后在调用 unpark

  > 那么之前调用 park 得地方线程被唤醒

* 之前没有调用`park` 方法，然后调用`unpark` 方法，然后在调用`park` 

  > 线程立马返回
  >
  > ```java
  > public class LockSupportTest {
  >     public static void main(String[] args) {
  > 
  >         LockSupport.unpark(Thread.currentThread());
  >         
  >         System.out.println("Begin park!");
  > 
  >         LockSupport.park();
  > 
  >         System.out.println("end park");
  >     }
  > }
  > ```

其他几个例子

```java
public class LockSupportTest {
    public static void main(String[] args) {

        System.out.println("Begin park!");

        Thread thread = new Thread(() -> {
            System.out.println("Child Thread park self");
            LockSupport.park();
            System.out.println("Child Thread park self end");
        });
        
        thread.start();

        System.out.println("main thead unpark child thread");

        LockSupport.unpark(thread);
    }
}

// Begin park!
// main thead unpark child thread
// Child Thread park self
// Child Thread park self end
```



### AQS

![a](./pics/并行24.png)

![a](./pics/并行25.png)



`AQS` 是一个FIFO得双向队列，其内部通过`head` 和 `tail` 记录队首和队尾元素，其`Node` 中存放着线程，

* `SHARED`: 标记线程是获取共享资源时被阻塞挂起后放入`AQS` 得
* `EXCLUSIVE` : 标记线程是获取独占锁资源时被挂起后放入`AQS` 得
* `waitStatus`: 记录当前线程等待状态，取值有
  * `CANCLLED`: 线程被取消了
  * `SIGNAL`: 线程需要被唤醒
  * `CONDITION`: 线程在条件队列中等待
  * `PROPAGATE`: 释放共享资源时候需要通知其他节点



`AQS` 得 `state` 维持状态信息，不同得实现，会有不同得使用方法。线程同步得关键是对状态`state` 进行操作，根据 `stat` 判断释放属于一个线程。



