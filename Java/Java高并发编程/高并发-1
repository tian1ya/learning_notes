每一个线程都有它的父线程，一个线程得创建肯定是有另外一个线程完成的。

程序的执行入口使main 函数，main函数也就是jvm创建的一个线程，那就意味着我们前面创建的所有线程，其父线程都是main线程

创建线程得时候还可以指定一个线程组 ThreadGroup ，如果没有指定那么，创建的线程都在父线程所在的线程组里面

Thread 负责线程本身相关的职责和控制，而Runnable则负责逻辑执行单元的部分

堆内存，是JVM中最大的一块内存区域，被所有的线程共享，java 在运行期间创建的所有对象几乎都是存放在该内存区域，该内存区域也是垃圾回收机制重点光顾的区域， 所以也成为使GC堆

方法区，也是被多个线程所共享的内存区域，主要用于存储已经被虚拟机加载的类信息、常量、静态变量，也称为是 『持久带』

栈内存是线程私有的。

一个线程得内存大小：堆内存 + 线程数量 * 栈内存

守护线程：
	thread.setDaemon(true) 设置线程 thread 为守护线程。如果设置 false，为正常守护线程,只在线程启动之前才有效
	.isDaemon() 判断是否守护线程

	假如你在main 函数中写一个非守护线程(没有对这个线程setDaemon(true)，假如在你的例子中你将这个线程sleep了10秒)，现在你的main函数结束了，但是你的JVM进程则永远不会退出，原因是进程中存在一个非守护线程在运行，如果你将这个线程setDaemon(true)，那么当main进程结束之后，JVM也会随之退出运行，你的thread 线程也会结束。

	线程是否为守护线程和它的父线程由很大的关系，如果父线程是正常线程，则子线程也是正常线程。

	如果一个JVM进程中没有一个非守护线程，那么JVM会退出，也就是说守护线程具备自动结束生命周期的特性，，想想一下，假如垃圾回收机制是非守护进程，那么当程序结束的时候，jvm无法退出，因为垃圾回收机制还在运行。

	守护线程一般会使用后台任务，当你在结束你的主要任务的时候，你的后台任务自动的结束。

sleep 方法：在sleep 的时候当前线程是不会放弃锁得。
	java1.5 提供了TimeUnit 的工具，当使用sleep 的时候，使用这个工具的sleep 方法：在sleep

setPriority()和getPriority() 设置优先级
	但是jvm调用你的线程得时候，并不会如你所愿的按照优先级调用区执行，线程得执行完成时按照 cpu 的执行来调用
	一般情况下，不会对线程设定优先级别，更不会使得某些业务严重的依赖线程优先级，使用默认的优先级就可以。

getID() 获取线程唯一的id

线程interrupt 就是将进入阻塞状态的线程打断阻塞。这里理解下，打断一个线程，并不是结束该现成的生命周期，而仅仅是打断当前线程得阻塞状态。

isInterrupt() 判断当前线程是否被阻断

join 方法，这个方法也是一个可中断的方法。join 某个线程A，那么就会使得当前线程B进入等待，直到A线程结束，或者到达给定的时间，那么在此期间B线程是处于Bolcked 的状态，join方法最开始是由当前线程发起的。

关闭一个线程：
	当这个线程正常运行结束的时候，这个线程就会关闭

死锁，就是线程没有日志输出，也没有在做任何的作业，看着就想线程死掉一样，实际上并没有，可以有一些可视化的工具查看死锁得问题。

资源共享：多个线程同时对同一个资源进行访问和操作(读写)，如果多个线程访问到的数据是一致的，则称为数据同步或者资源同步。

数据不一致得问题：
	a=1
	a += 1;
	sout(a)
	假如是上面的代码，当一个线程来的时候给a + 1，但此时还没有输出，cpu将执行权利交给了另外一个线程，而这个线程也 a+1,cpu又将执行权利交给我第一个线程，第一个线程输出的a等于3，而不是2，这就是数据不一致。这个问题就是多个线程对同一个资源操作而引起的问题。

	线程得执行全靠cpu 的调度，哪个线程先执行，哪个线程后执行，这和线程等待多久是没有关系的

synchronized 关键字，提供了一种排他机制，也就是在同一个时间只能有一个线程去执行某些操作，
	提供了一种锁得机制，能够确保共享变量得互斥访问，防止数据不一致问题的出现
	确保任何线程在访问资源的时候都是从主内存中获取得到资源

	只能对代码块或者方法惊喜修饰，不能用于class以及变量

	当使用这个关键字的时候，一个线程在执行，那么其它线程都是处于阻塞状态的。

	synchronized关联的对象不能为 null

	对于同一个类中的不同的方法使用 该关键字，当启动两个线程，分别执行这俩个方法的时候(引用的俩个方法都是来自于同一个new 出来的对象)，那么这两个方法争强的是通一把锁，都是这个对象(thisMonitor)的锁.

	同样的如果，对于同一个类中的不同的静态方法使用 该关键字，当启动两个线程，分别执行这俩个静态方法的时候(引用的俩个方法都是来自于同一个new 出来的对象)，那么这两个方法争强的是通一把锁，都是这个对象(classMonitor)

	synchronized 效率低：
		synchronized 的作用域太大，所有经过这个作用域的线程都必须串行地经过。
		当这个关键字将其它线程阻塞之后，阻塞的时长并不能够被控制。
			如线程A获得锁之后，再执行方法执行了一个小时，而线程B得方法能够执行的前提是线程A将锁释放，如果线程B在逻辑中，如果等待5分钟不能拿到锁，那么就放弃执行，显然使用 synchronized 是做不到的，

		且阻塞不能被打断。
			还是上面的例子，当你在主线程打断并不能讲其打断


	死锁：交叉锁导致死锁，

	线程之间的通信：
		同步阻塞消息处理：缺陷
			两次提交的时间会较长
			系统的吞吐量不足

		异步非阻塞
		单线程间通信：通知机制，如果队列中有Event那么通知工作的线程开始工作，如果没有那么工作线程 休息并等待通知。

			wait和notify：线程进入阻塞和阻塞线程被唤醒。
				wait 和 notify 都不是Thread 特有的方法，而是Object 中的方法，在JDK中的每一个类都拥有这俩个方法，
				wait 的几个重载方法都会调用 wait(long timeout) 方法，wait()相当于wait(0),0代表永不超时，

				wait 方法会导致当前线程进入阻塞，直到有其他线程调用了Object 的notify()或者的notifyAll()方法，或者阻塞线时间到达了timeout时间，而自动唤醒。

				wait 方法必须是在同步方法中使用，当前线程调用wait 方法之后，将会放弃对该monitor(锁) 的所有权而进入与该对象关联的 waitset中

				注意wait和notify都是与当前的同步方法对象绑定，如下的方法是错误的

				private Object o = new Object;
				private synchronized void testWait(){
					o.wait();
					sout("wwwait testWait")
				}

				wait 会放弃锁，但是 notify不会放弃锁

				当在main 方法中测试这个方法的时候，会出现错误，原因是，synchronized monitor
				 的是 this，但是调用 wait的却是 o 这个对象。 

		notifyAll 唤醒全部被阻塞的线程，唤醒的线程人会等待cpu 的召唤然后再去执行。

		边界条件而出现的线程数据不同步的问题[脏读问题]
			将判断边界条件的判断从 if 换为 while 循环，notify换为notify就能解决

ThreadGroup
	默认情况下，新的线程都会被加入到main 线程所在的group中。
	创建ThreadGroup 的语法：
	public ThreadGroup(String name); 这个 threadGroup 的父 threadGroup 还是创建它的线程得 threadGroup。
	public ThreadGroup(ThreadGroup parent, String name); 给定义一个 threadGroup


线程运行时期的异常：
	处理运行时的异常的API总共有4个。
		UncaughtExceptionHandler:当线程在运行过程中出现异常时候，就会调用这个接口，从而得知是哪个线程出现了异常，
			以及出现了什么样的错误。

	什么是钩子Hook：
		系统就是一个信息传递处理的一个过程，而钩子就是一种特殊的信息处理方式，特殊在它的存在是对专门的事情做处理的，如果这个事情没有发生，那么钩子就不会出发，当事情触发的时候，钩子就会被触发来处理这个事情，如键盘钩子就是处理，当键盘被操作的时候。
线程池：主要目的是为了利用线程，提高系统效率，Thread是一个重量级的资源，创建，销毁都是比较耗系统资源的，所以线程得重复利
	用很关键。

	先城池就是一个池子，里面放着很多已经创建好的线程，当有任务提交给线程池执行的时候，池子中的某个线程会主动执行该任务，如果池子中线程数量不够应付数量众多的任务的时候，需要自动扩充新的线程到池子中，当任务比较少的时候，池子中的线程能够
	自动回收，释放资源，还需要一个任务队列，为的是，能够异步的提交任务和缓存未被处理的任务，
	综上，一个完整的线程池应该具备如下要素：
	1、任务队列：用于缓存提交的任务
	2、线程数量管理功能，线程池要能够很好的管理和控制线程数量，下面三个参数来实现：
		1、创建线程池时初始化的线程数量。				init
		2、线程池自动扩充的时候，最大扩充的线程数量		max
		3、线程池中的线程空闲的时候需要释放线程但也需要维护一定数量的活跃数量或者核心数量。core
		init <= core <= max

	3、任务拒绝策略，如果线程数量已到达上闲，且任务队列已满，则需要有相应的拒绝策略。
	4、线程工厂，主要用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等。
	5、QueueSize:
	6、Keepedlive 时间

类的加载过程：
	ClassLoader 主要职责就是负责加载各种class文件到JVM中，

	类的加载过程，主要分位三大阶段：
		加载阶段：主要负责查找并加载类的二进制数据文件，也就是class 文件
		连接阶段：这个阶段做的比较多，
			验证：确保类的正确性
			准备：为类的静态变量分配内存，并且初始化默认值
			解析：把类中的符号引用转换为直接引用
		初始化阶段：为类的静态变量赋予正确的初始值，对类的初始化时一个延迟的机制，当类首次主动使用的时候，才会被初始化，在同一个包中一个class 只会被初始化一次

	主动使用：
		1、new 方法创建对象
		2、访问静态变量或方法的时候
		3、对每个类进行反射操作
		4、初始化子类引起父类的初始化，通过子类访问父类的静态变量，并不会使得子类得到初始化，而是初始化父类。
		5、启动类，执行类中的main 方法。

	类加载就是将class 文件中的二进制数据读取到内存中，然后将该字节流所代表的静态存储结构转换为方法区中运行时候的数据结构，并且在堆内存中生成一个Class 对象。

	三大类加载器：
		根类加载器：最顶层的加载器，C++编写，主要负责虚拟机核心类库的加载，如整个java.lang包都是它加载的，

		扩展类加载器，它主要用于加载 JAVA_HOME下的jre\lb\ext子目录下的类库，你也可以讲自己的类打包为jar 包，放到扩展类加载器所在的路径中，扩展类加载器会负责加载你所需要的类，

		系统类加载器，负责将classPath下的类库资源加载，在系统开发的时候引入的第三方jar包，

	可以自定义一个类加载器，实现接口 ClassLoader，然后实现接口中的方法findClass

	父委托机制(双亲委托机制)
		当一个类加载器被调用loadClass之后，它并不会直接将其加载，而是先交给当前类加载器的父类尝试加载直到到达最顶层的父加载器，然后再依次向下执行加载。

		可以破坏这种加载机制

	类加载器命名空间
		每一个类加载器都有自己的命名空间，命名空间是由该加载器及所有父加载器所构成的，每一个类加载器中同一个class都是独一无二的，只有一份。

		运行时的包：编写代码的时候通常会给一个类指定一个包名，其作用就是组织类，防止不同包下同样的class引起冲突，运行时候的包是由类加载器的命名空间和类的全限定名称共同组成的。

		JVM规定再运行的时候，不同的包下的类彼此之间时不可以进行访问的，但是这些类再程序启动的时候，会被各种各样的加载器加载，从而实现各个包里面类的互相使用，且不同包下的相同名称的类也是可以存在的。

		再堆内存中如果一个对象没有被应用那么就会被GC干掉。class对象及class 再方法区中数据结构被收回，需要满足一下三个条件会被GC回收
			1、该类所有实例都已被GC，
			2、加载该类的classLoader实例被回收
			3、该类的class 实例没有在其它地方引用















	
	



































