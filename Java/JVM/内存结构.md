![a](./pic/jvm3.png)

* 虚拟机指令执行流程

  java 源代码 -> jvm 指令 -> 解释器翻译为机器码 -> CPU 运行

* 程序计数器的作用

  记住下一条jvm指令的执行地址，在解释器翻译jvm指令的时候，程序计数器就准备好了下一条指令的地址，然后解释器执行完当前后，从计数器哪里取到下一条指令的地址，然后去执行。

  物理上，通过一个寄存器实现计数器

* 计数器特点:

  * 线程私有的，属于当前执行线程
  * 在Java 虚拟机规范中，唯一一个不存在内存溢出问题的区域

* 虚拟机栈

  * 栈数据结构：先入后出(后入先出)
  * 栈中的每个元素，称为栈帧，每个栈帧对应一次方法的调用所需要的内存(方法中有参数，局部变量等)

  ![a](./pic/jvm4.png)

  ​	

  * 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

  <img src="./pic/jvm5.png" alt="a" style="zoom:50%;" />

  IDEA 看到这个时候栈中有一个栈帧。

  <img src="./pic/jvm6.png" alt="a" style="zoom:50%;" />

  继续执行后看到有2个栈帧了。且最上面的是当前活动栈帧，将上一个栈帧，压入到栈内。

  <img src="./pic/jvm7.png" alt="a" style="zoom:50%;" />

  继续执行。

* 栈问题

  * 垃圾回收是否涉及栈内存？

    * 栈帧就是方法的一次次调用，每次活动栈执行结束之后，就会将栈中的变量等占的内存重栈中弹出，而释放栈内存。GC只回收heap 中的内存。

  * 栈内存分配越大越好么？

    * <img src="./pic/jvm8.png" alt="a" style="zoom:50%;" />
    * <img src="./pic/jvm12.png" alt="a" style="zoom:50%;" />
    * 栈设置大，反而使得线程数变少，总共物理内存是有限的，栈越大，那么线程就会变少。栈设置大智能会允许更多次的方法调用(递归深度)，并不能增强允许效率。一般使用系统默认大小就OK。

  * 方法内的局部变量是否线程安全

    * 一个线程对于一个栈，栈之间是独立的，而局部变量是数据栈内存中的数据，所以方法内的局部变量不会存在线程不安全的问题，局部变量不会受不同线程的干扰。每个线程都持有这个参数
    * <img src="./pic/jvm9.png" alt="a" style="zoom:50%;" />
    * 但是如果局部变量为 static 的，那就不一样了，多个线程都会读取同一个变量，存在线程安全问题，这个时候变量是共享的了。
    * <img src="./pic/jvm10.png" alt="a" style="zoom:50%;" />

    一下的例子来讲讲栈和线程安全

    <img src="./pic/jvm11.png" alt="a" style="zoom:50%;" />

    其中方法 m1 是线程安全的，但是方法m2和 m3不是线程安全的，方法m2因为参数sb是传进来的，意味着其他的线程中执行的方法也会修改该参数，而方法m3也不按照，将sb 返回了意味着，

    上述后2个方法变量逃离了函数的域范围，所以：

    * 方法内局部变量没有逃离方法的作用范围，那么就是线程安全的，反之，不安全
    * 如果局部变量是应用的对象，并逃离方法作用范围，则考虑线程安全问题

  * 栈内存溢出

    * 栈帧过多导致，栈大小是固定的，方法的调用链过长(如递归)
    * 栈帧过大: 局部变量过大，这个不多出现

* 线程诊断

  * cpu 占用过多

  使用`top` 命令查看

  <img src="./pic/jvm13.png" alt="a" style="zoom:50%;" />

  ​	但是 `top` 只能看到进程(PID)对cpu的占用情况，看不到线程(tid)

  ​	使用 `ps` 则看出线程对 cpu占用 `ps H -eo pid,tid,%cpu `

     H: 打印进程数， -eo 打印感兴趣的内容(列)

    <img src="./pic/jvm14.png" alt="a" style="zoom:50%;" />

  然后过滤

  <img src="./pic/jvm15.png" alt="a" style="zoom:50%;" />

  使用 jstack 进程id

  <img src="./pic/jvm16.png" alt="a" style="zoom:50%;" />

  查看进程下，所有线程的情况

  <img src="./pic/jvm17.png" alt="a" style="zoom:50%;" />

  注意jstack 中进程变化 nid 是16进制的，而ps 中的是10进制的，需要进行换算，才能准确定位

  上述中使用 jstack 中的线程信息都能定位到代码的行数

  <img src="./pic/jvm18.png" alt="a" style="zoom:50%;" />

  * 程序运行很长时间没有结果

    * 可能是多个线程发生死锁， jstack 最后可以诊断出来。如下死锁例子

      <img src="./pic/jvm19.png" alt="a" style="zoom:50%;" />

* 本地方法栈：不是Java编写的方法，如C/C++, 用于和本地操作系统完成调用

  * 如所有类的父类，Object 中的一些使用 `native` 标识的方法

    ```java
    public native int hashCode();
    ```

    这些方法都是由C/C++ 实现的

* 堆

  * 通过 new 关键字创建的对象都会使用堆内存

  * 它是线程共享的，堆中对象都需要考虑线程安全的问题(栈中变量是线程独有的)

  * 有垃圾回收机制(栈中没有)：没有被引用的对象会被回收掉

  * 堆内存溢出问题：

    * <img src="./pic/jvm20.png" alt="a" style="zoom:50%;" />

      上述 a 变量不断增加，list 变量一直被引用，里面的东西一直在增加，于是就本占满

    * 修改堆内存参数，模型是4G

      * 现在将其改为 8m
        * <img src="./pic/jvm21.png" alt="a" style="zoom:50%;" />
        * 代码运行：
        * <img src="./pic/jvm22.png" alt="a" style="zoom:50%;" />
        * 修改前后的循环次数发生了变化，

  * 堆内存诊断的工具

    * jps: 查看当前系统中有哪些java 进程

    * jmap: 查看某一时刻堆内存占用情况

    * jconsole: 图形界面，多功能的检测工具，可以连续检测

      <img src="./pic/jvm23.png" alt="a" style="zoom:50%;" />

      在新创建的对象，在使用 jmap 命令的时候，在区域Eden可以看到新创建的对象对堆的使用情况

      <img src="./pic/jvm24.png" alt="a" style="zoom:50%;" />

      Jconsole 使用

      <img src="./pic/jvm25.png" alt="a" style="zoom:50%;" />

      使用另外一个更强大的分析堆内存分析工具，这个工具中使用 heapdump 工具

      <img src="./pic/jvm26.png" alt="a" style="zoom:50%;" />

* 方法区：所有jvm 虚拟机共享的区域，里面存储着和类的结构相关的信息，运行时字段，方法，构造器，方法区在虚拟机启东市创建，逻辑上是堆的组成部分，具体实现上有不同的，1.8中方法区之间放置在物理机内存中

  * <img src="./pic/jvm27.png" alt="a" style="zoom:50%;" />

    <img src="./pic/jvm28.png" alt="a" style="zoom:50%;" />

    ​	1.8 之后的永久代被移除，而将方法区放置在元空间中，这个元空间交给物理机器内容管理，而不是jvm，且默认是没有设置上限的，所以很难出现堆内存溢出

    ​	如下代码演示元空间溢出

    <img src="./pic/jvm29.png" alt="a" style="zoom:50%;" />

    代码可以执行结束，且没有溢出。如果设置元空间大小 `-Xx:MaxMetaspaceSize8m` ，继续执行，就跑出异常

    <img src="./pic/jvm30.png" alt="a" style="zoom:50%;" />

  不设置上面的那个元空间参数，使用1.8以前的java 版本，

  <img src="./pic/jvm31.png" alt="a" style="zoom:50%;" />

  其错误日志是 永久代内存溢出

* 运行时常量池

  * <img src="./pic/jvm32.png" alt="a" style="zoom:50%;" />

  * 什么是运行时常量池

    指令查找的一些常量符号，

    如下是一段Java 代码

    ```java
    public class rmbConverter {
        public static void main(String[] args) {
            System.out.println("hellWorld");
        }
    }
    ```

    运行之后在target 下会生成 .class 文件，然后使用jdk 自带的命令对二进制文件进行反编译

    ```shell
    javap -v rmbConverter.class
    ```

    之后会输出很多的东西

    ```java
    ~/» javap -v rmbConverter.class              
    Classfile /Users/xuxliu/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei/rmbConverter.class
      Last modified Aug 11, 2020; size 583 bytes
      MD5 checksum 5b48d525c273e5aecada2b5476aedcd6
      Compiled from "rmbConverter.java"
    public class com.it.leetcode.huawei.rmbConverter
      minor version: 0
      major version: 52
      flags: ACC_PUBLIC, ACC_SUPER
    Constant pool:
       #1 = Methodref          #6.#20         // java/lang/Object."<init>":()V
       #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;
       #3 = String             #23            // hellWorld
       #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V
       #5 = Class              #26            // com/it/leetcode/huawei/rmbConverter
       #6 = Class              #27            // java/lang/Object
       #7 = Utf8               <init>
       #8 = Utf8               ()V
       #9 = Utf8               Code
      #10 = Utf8               LineNumberTable
      #11 = Utf8               LocalVariableTable
      #12 = Utf8               this
      #13 = Utf8               Lcom/it/leetcode/huawei/rmbConverter;
      #14 = Utf8               main
      #15 = Utf8               ([Ljava/lang/String;)V
      #16 = Utf8               args
      #17 = Utf8               [Ljava/lang/String;
      #18 = Utf8               SourceFile
      #19 = Utf8               rmbConverter.java
      #20 = NameAndType        #7:#8          // "<init>":()V
      #21 = Class              #28            // java/lang/System
      #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
      #23 = Utf8               hellWorld
      #24 = Class              #31            // java/io/PrintStream
      #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
      #26 = Utf8               com/it/leetcode/huawei/rmbConverter
      #27 = Utf8               java/lang/Object
      #28 = Utf8               java/lang/System
      #29 = Utf8               out
      #30 = Utf8               Ljava/io/PrintStream;
      #31 = Utf8               java/io/PrintStream
      #32 = Utf8               println
      #33 = Utf8               (Ljava/lang/String;)V
    {
      public com.it.leetcode.huawei.rmbConverter();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
          stack=1, locals=1, args_size=1
             0: aload_0
             1: invokespecial #1   // Method java/lang/Object."<init>":()V
             4: return
          LineNumberTable:
            line 14: 0
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       5     0  this   Lcom/it/leetcode/huawei/rmbConverter;
    
      public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
          stack=2, locals=1, args_size=1
             0: getstatic     #2  // Field java/lang/System.out:Ljava/io/PrintStream;
             3: ldc           #3  // String hellWorld(java虚拟机加上去的注释)
             5: invokevirtual #4  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
             8: return
          LineNumberTable:
            line 16: 0
            line 17: 8
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       9     0  args   [Ljava/lang/String;
    }
    SourceFile: "rmbConverter.java"
    ```

    以上的内容主要包含3部分

    * 类基本信息也就是1到9行
    * 常量池，也就是10行到43行
    * 类方法定义，包括虚拟机指令

    常量池就是所有的虚拟指令的符号。在59行是说明类的main 函数，在这个函数中Code部分包含着虚拟机的指令，指令分别

    * getstatic：获取静态变量
    * ldc: 加载一个参数
    * Invokevietual：虚方法调用
    * return:  执行结束

    也就是在main函数中一句代码

    ```java
    System.out.println("hellWorld");
    ```

    变成了上述的4条虚拟机指令，那么这些指令如何解释呢

    如getstatic：会根据后面的`#2`等进行查表翻译，查表的去处就是去常量池中去查，如`#2` 在常量池中

    `#2 = Fieldref           #21.#22        // `

    `#2` 引用了成员变量，`#21.#22`,然后根据他继续查找

    `#21 = Class              #28`  

    `#22 = NameAndType        #29:#30`

    `#21` 表示的是一个类，一个什么类呢，是由`#28` 去指定的，   

    `#28 = Utf8               java/lang/System` 

    所以`#21`  指向的是一个`java/lang/System` 类，然后会到最开始`#21.#22 `

    `#22` 指向`#29` 

    `#29 = Utf8               out` ， 而在`#29:#30` 写法是说明 `#29的类型是#30`

    而`#30 = Utf8               Ljava/io/PrintStream;`

    所以综上 `#2` 指令是去找 java/lang/System`java/lang/System.out` 的静态方法。

    也就是 getstatic 指令完成后获取到 `java/lang/System.out` 的静态方法。

    然后下一个指令

    ldc: 获取引用地址，那么找那个引用地址呢？超看常量池中的 `#3` 指向链为

    ```shell
    #3 = String             #23
    #23 = Utf8               hellWorld
    ```

    也就是去取 `hellWorld` 这个变量的引用，最后 ldc 获取到 `hellWorld`

    然后jvm指令 invokevirtual  调用一个虚方法调用，#4指向了那个虚方法，

    ```shel
    #4 = Methodref          #24.#25
    #24 = Class              #31
    #31 = Utf8               java/io/PrintStream
    
    #25 = NameAndType        #32:#33（具体的方法调用和方法参数类型）
    #32 = Utf8               println
    #33 = Utf8               (Ljava/lang/String;)V
    ```

    综上：什么是常量池

    **常量池就是一张表，虚拟机指令根据这张常量表找到需要执行的类名，方法名，参数类型，字面量等信息**

    **运行时常量池，常量池是.class 文件中的，当该类被加载，它的常量池信息就被放入运行时常量池，并且把里面的符号地址变为真实地址**

    ---

    * StringTable(串池)

    一段代码

    ```java
    public class rmbConverter {
        public static void main(String[] args) {
            String s1 = "a";
            String s2 = "b";
            String s3 = "ab";
        }
    }
    ```

    反编译

    ```java
    ~» javap -v rmbConverter.class                  
    Classfile /Users/xuxliu/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei/rmbConverter.class
      Last modified Aug 11, 2020; size 534 bytes
      MD5 checksum 20363d6785b6e62b5ddd96f037deee69
      Compiled from "rmbConverter.java"
    public class com.it.leetcode.huawei.rmbConverter
      minor version: 0
      major version: 52
      flags: ACC_PUBLIC, ACC_SUPER
    Constant pool:
       #1 = Methodref          #6.#24         // java/lang/Object."<init>":()V
       #2 = String             #25            // a
       #3 = String             #26            // b
       #4 = String             #27            // ab
       #5 = Class              #28            // com/it/leetcode/huawei/rmbConverter
       #6 = Class              #29            // java/lang/Object
       #7 = Utf8               <init>
       #8 = Utf8               ()V
       #9 = Utf8               Code
      #10 = Utf8               LineNumberTable
      #11 = Utf8               LocalVariableTable
      #12 = Utf8               this
      #13 = Utf8               Lcom/it/leetcode/huawei/rmbConverter;
      #14 = Utf8               main
      #15 = Utf8               ([Ljava/lang/String;)V
      #16 = Utf8               args
      #17 = Utf8               [Ljava/lang/String;
      #18 = Utf8               s1
      #19 = Utf8               Ljava/lang/String;
      #20 = Utf8               s2
      #21 = Utf8               s3
      #22 = Utf8               SourceFile
      #23 = Utf8               rmbConverter.java
      #24 = NameAndType        #7:#8          // "<init>":()V
      #25 = Utf8               a
      #26 = Utf8               b
      #27 = Utf8               ab
      #28 = Utf8               com/it/leetcode/huawei/rmbConverter
      #29 = Utf8               java/lang/Object
    {
      public com.it.leetcode.huawei.rmbConverter();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
          stack=1, locals=1, args_size=1
             0: aload_0
             1: invokespecial #1  // Method java/lang/Object."<init>":()V
             4: return
          LineNumberTable:
            line 14: 0
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       5     0  this   Lcom/it/leetcode/huawei/rmbConverter;
    
      public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
          stack=1, locals=4, args_size=1
             0: ldc           #2                  // String a
             2: astore_1
             3: ldc           #3                  // String b
             5: astore_2
             6: ldc           #4                  // String ab
             8: astore_3
             9: return
          LineNumberTable:
            line 16: 0
            line 17: 3
            line 18: 6
            line 19: 9
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0      10     0  args   [Ljava/lang/String;
                3       7     1    s1   Ljava/lang/String;
                6       4     2    s2   Ljava/lang/String;
                9       1     3    s3   Ljava/lang/String;
    }
    SourceFile: "rmbConverter.java"
    ```

    到main 方法55行开始，查看jvm 指令，第一个指令60行，加载一个引用，这个应用执行常量池中的`#2`

    ```shell
    #2 = String             #25            // a
    #25 = Utf8               a
    ```

    加载变量a，

    61行指令 `astore_1`  存储局部变量，将上一条指令拿到的引用值存储到局部变量，也就是72行部分，存储的编号(slot)为1，然后后面的3，4。6，8指令和上述一样的过程，于是局部变量表中就存储了3个值。

    当代码开始运行的时候，常量池信息加载到运行时常量池中，这个时候加载进来的变量都仅仅是常量池中的符号，而并没有实例化(没有变为java 对象)，当具体执行到引用他的代码中也就是执行到 `ldc` 的地方，然后将符号变为java 的对象，然后准备好一块空间，就是串池`StringTable`，就是一个哈希表

    ```java
    StringTable []
    ```

    这个时候会去串池中找实例化的对象`a`,发现并没有，于是创建`a` 然后添加到串池中，

    ```java
    StringTable [ "a" ]
    ```

    然后在执行`3: ldc           #3` 在串池中找变量 `b` 字符串对象，发现并没有，然后创建并将`b` 加入进去，`ac` 也是一样的，最后串池

    ```java
    StringTable [ "a" "b" "ab"]
    ```

    代码改为：

    ```java
    public class rmbConverter {
        public static void main(String[] args) {
            String s1 = "a";
            String s2 = "b";
            String s3 = "ab";
            String s4 = s1 + s2;
        }
    }
    ```

    反编译

    ```java
    ~/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei » javap -v rmbConverter.class                     xuxliu@CNxuxliu-2
    Classfile /Users/xuxliu/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei/rmbConverter.class
      Last modified Aug 11, 2020; size 534 bytes
      MD5 checksum 20363d6785b6e62b5ddd96f037deee69
      Compiled from "rmbConverter.java"
    public class com.it.leetcode.huawei.rmbConverter
      minor version: 0
      major version: 52
      flags: ACC_PUBLIC, ACC_SUPER
    Constant pool:
       #1 = Methodref          #6.#24         // java/lang/Object."<init>":()V
       #2 = String             #25            // a
       #3 = String             #26            // b
       #4 = String             #27            // ab
       #5 = Class              #28            // com/it/leetcode/huawei/rmbConverter
       #6 = Class              #29            // java/lang/Object
       #7 = Utf8               <init>
       #8 = Utf8               ()V
       #9 = Utf8               Code
      #10 = Utf8               LineNumberTable
      #11 = Utf8               LocalVariableTable
      #12 = Utf8               this
      #13 = Utf8               Lcom/it/leetcode/huawei/rmbConverter;
      #14 = Utf8               main
      #15 = Utf8               ([Ljava/lang/String;)V
      #16 = Utf8               args
      #17 = Utf8               [Ljava/lang/String;
      #18 = Utf8               s1
      #19 = Utf8               Ljava/lang/String;
      #20 = Utf8               s2
      #21 = Utf8               s3
      #22 = Utf8               SourceFile
      #23 = Utf8               rmbConverter.java
      #24 = NameAndType        #7:#8          // "<init>":()V
      #25 = Utf8               a
      #26 = Utf8               b
      #27 = Utf8               ab
      #28 = Utf8               com/it/leetcode/huawei/rmbConverter
      #29 = Utf8               java/lang/Object
    {
      public com.it.leetcode.huawei.rmbConverter();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
          stack=1, locals=1, args_size=1
             0: aload_0
             1: invokespecial #1                  // Method java/lang/Object."<init>":()V
             4: return
          LineNumberTable:
            line 14: 0
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       5     0  this   Lcom/it/leetcode/huawei/rmbConverter;
    
      public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
          stack=1, locals=4, args_size=1
             0: ldc           #2                  // String a
             2: astore_1
             3: ldc           #3                  // String b
             5: astore_2
             6: ldc           #4                  // String ab
             8: astore_3
             9: return
          LineNumberTable:
            line 16: 0
            line 17: 3
            line 18: 6
            line 19: 9
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0      10     0  args   [Ljava/lang/String;
                3       7     1    s1   Ljava/lang/String;
                6       4     2    s2   Ljava/lang/String;
                9       1     3    s3   Ljava/lang/String;
    }
    SourceFile: "rmbConverter.java"
    ------------------------------------------------------------
    ~/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei » javap -v rmbConverter.class                     xuxliu@CNxuxliu-2
    Classfile /Users/xuxliu/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei/rmbConverter.class
      Last modified Aug 12, 2020; size 718 bytes
      MD5 checksum 92311b42984e32a412f421e5f791c4e3
      Compiled from "rmbConverter.java"
    public class com.it.leetcode.huawei.rmbConverter
      minor version: 0
      major version: 52
      flags: ACC_PUBLIC, ACC_SUPER
    Constant pool:
       #1 = Methodref          #10.#29        // java/lang/Object."<init>":()V
       #2 = String             #30            // a
       #3 = String             #31            // b
       #4 = String             #32            // ab
       #5 = Class              #33            // java/lang/StringBuilder
       #6 = Methodref          #5.#29         // java/lang/StringBuilder."<init>":()V
       #7 = Methodref          #5.#34         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       #8 = Methodref          #5.#35         // java/lang/StringBuilder.toString:()Ljava/lang/String;
       #9 = Class              #36            // com/it/leetcode/huawei/rmbConverter
      #10 = Class              #37            // java/lang/Object
      #11 = Utf8               <init>
      #12 = Utf8               ()V
      #13 = Utf8               Code
      #14 = Utf8               LineNumberTable
      #15 = Utf8               LocalVariableTable
      #16 = Utf8               this
      #17 = Utf8               Lcom/it/leetcode/huawei/rmbConverter;
      #18 = Utf8               main
      #19 = Utf8               ([Ljava/lang/String;)V
      #20 = Utf8               args
      #21 = Utf8               [Ljava/lang/String;
      #22 = Utf8               s1
      #23 = Utf8               Ljava/lang/String;
      #24 = Utf8               s2
      #25 = Utf8               s3
      #26 = Utf8               s4
      #27 = Utf8               SourceFile
      #28 = Utf8               rmbConverter.java
      #29 = NameAndType        #11:#12        // "<init>":()V
      #30 = Utf8               a
      #31 = Utf8               b
      #32 = Utf8               ab
      #33 = Utf8               java/lang/StringBuilder
      #34 = NameAndType        #38:#39        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      #35 = NameAndType        #40:#41        // toString:()Ljava/lang/String;
      #36 = Utf8               com/it/leetcode/huawei/rmbConverter
      #37 = Utf8               java/lang/Object
      #38 = Utf8               append
      #39 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;
      #40 = Utf8               toString
      #41 = Utf8               ()Ljava/lang/String;
    {
      public com.it.leetcode.huawei.rmbConverter();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
          stack=1, locals=1, args_size=1
             0: aload_0
             1: invokespecial #1                  // Method java/lang/Object."<init>":()V
             4: return
          LineNumberTable:
            line 14: 0
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       5     0  this   Lcom/it/leetcode/huawei/rmbConverter;
    
      public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
          stack=2, locals=5, args_size=1
             0: ldc           #2                  // String a
             2: astore_1
             3: ldc           #3                  // String b
             5: astore_2
             6: ldc           #4                  // String ab
             8: astore_3
             9: new           #5      // class java/lang/StringBuilder
            12: dup
            13: invokespecial #6  // Method java/lang/StringBuilder."<init>":()V
            16: aload_1
            17: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
            20: aload_2
            21: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
            24: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
            27: astore        4
            29: return
          LineNumberTable:
            line 16: 0
            line 17: 3
            line 18: 6
            line 19: 9
            line 20: 29
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0      30     0  args   [Ljava/lang/String;
                3      27     1    s1   Ljava/lang/String;
                6      24     2    s2   Ljava/lang/String;
                9      21     3    s3   Ljava/lang/String;
               29       1     4    s4   Ljava/lang/String;
    }
    ```

    Main 方法中152行到157行和之前的指令是一样的，然后在执行 `String s4 = s1 + s2` 的时候，先new 了一个 `StringBuilder`, 然后160行代码调用一个方法，这个方法是 `StringBuilder` 中的一个特殊方法

    `Method java/lang/StringBuilder."<init>":()` 也就是 `StringBuilder` 的无参构造函数，然后161行 `aload_1`  从 局部变量表中将`slot=1`的变量取出，然后162行调用了`StringBuilder.append` 方法，该方法接收一个`Ljava/lang/String; 变量`，并返回 `Ljava/lang/StringBuilder` 下面的过程也是一样的

    整个 ``String s4 = s1 + s2` 代表的是 `new StringBuilder().append("a").append("b").toString()` 的过程，然后 `astore_4` 将结果存储在 slot 4 的局部变量表中，最后在执行 `.toString()` 的时候，在`StringBuilder` 的源码中，是new

    String(value)的操作，所以S4对象是存储在堆中的，所以如果执行

    `s3 == s4`

    返回 `false` 二者值相同，但是是两个对象。

    新的Java 代码

    ```java
        public static void main(String[] args) {
            String s1 = "a";
            String s2 = "b";
            String s3 = "ab";
            String s4 = s1 + s2;
            String s5 = "a" + "b";
        }
    }
    ```

    继续反编译

    ```she
    ~/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei » javap -v rmbConverter.class                     xuxliu@CNxuxliu-2
    Classfile /Users/xuxliu/Ifoods/Java/leetcode/target/classes/com/it/leetcode/huawei/rmbConverter.class
      Last modified Aug 12, 2020; size 741 bytes
      MD5 checksum 90192394835a6e3912670d2263af8648
      Compiled from "rmbConverter.java"
    public class com.it.leetcode.huawei.rmbConverter
      minor version: 0
      major version: 52
      flags: ACC_PUBLIC, ACC_SUPER
    Constant pool:
       #1 = Methodref          #10.#30        // java/lang/Object."<init>":()V
       #2 = String             #31            // a
       #3 = String             #32            // b
       #4 = String             #33            // ab
       #5 = Class              #34            // java/lang/StringBuilder
       #6 = Methodref          #5.#30         // java/lang/StringBuilder."<init>":()V
       #7 = Methodref          #5.#35         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
       #8 = Methodref          #5.#36         // java/lang/StringBuilder.toString:()Ljava/lang/String;
       #9 = Class              #37            // com/it/leetcode/huawei/rmbConverter
      #10 = Class              #38            // java/lang/Object
      #11 = Utf8               <init>
      #12 = Utf8               ()V
      #13 = Utf8               Code
      #14 = Utf8               LineNumberTable
      #15 = Utf8               LocalVariableTable
      #16 = Utf8               this
      #17 = Utf8               Lcom/it/leetcode/huawei/rmbConverter;
      #18 = Utf8               main
      #19 = Utf8               ([Ljava/lang/String;)V
      #20 = Utf8               args
      #21 = Utf8               [Ljava/lang/String;
      #22 = Utf8               s1
      #23 = Utf8               Ljava/lang/String;
      #24 = Utf8               s2
      #25 = Utf8               s3
      #26 = Utf8               s4
      #27 = Utf8               s5
      #28 = Utf8               SourceFile
      #29 = Utf8               rmbConverter.java
      #30 = NameAndType        #11:#12        // "<init>":()V
      #31 = Utf8               a
      #32 = Utf8               b
      #33 = Utf8               ab
      #34 = Utf8               java/lang/StringBuilder
      #35 = NameAndType        #39:#40        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      #36 = NameAndType        #41:#42        // toString:()Ljava/lang/String;
      #37 = Utf8               com/it/leetcode/huawei/rmbConverter
      #38 = Utf8               java/lang/Object
      #39 = Utf8               append
      #40 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;
      #41 = Utf8               toString
      #42 = Utf8               ()Ljava/lang/String;
    {
      public com.it.leetcode.huawei.rmbConverter();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
          stack=1, locals=1, args_size=1
             0: aload_0
             1: invokespecial #1                  // Method java/lang/Object."<init>":()V
             4: return
          LineNumberTable:
            line 14: 0
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0       5     0  this   Lcom/it/leetcode/huawei/rmbConverter;
    
      public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
          stack=2, locals=6, args_size=1
             0: ldc           #2                  // String a
             2: astore_1
             3: ldc           #3                  // String b
             5: astore_2
             6: ldc           #4                  // String ab
             8: astore_3
             9: new           #5                  // class java/lang/StringBuilder
            12: dup
            13: invokespecial #6   // Method java/lang/StringBuilder."<init>":()V
            16: aload_1
            17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
            20: aload_2
            21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
            24: invokevirtual #8    // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
            27: astore        4
            29: ldc           #4                  // String ab
            31: astore        5
            33: return
          LineNumberTable:
            line 16: 0
            line 17: 3
            line 18: 6
            line 19: 9
            line 20: 29
            line 21: 33
          LocalVariableTable:
            Start  Length  Slot  Name   Signature
                0      34     0  args   [Ljava/lang/String;
                3      31     1    s1   Ljava/lang/String;
                6      28     2    s2   Ljava/lang/String;
                9      25     3    s3   Ljava/lang/String;
               29       5     4    s4   Ljava/lang/String;
               33       1     5    s5   Ljava/lang/String;
    }
    SourceFile: "rmbConverter.java"
    ```

    在 87 行是执行完 `String s4 = s1 + s2;` 在执行到88行的时候，执行到代码 `String s5 = "a" + "b";` 的时候，执行到了jvm 指令 #4

    ```shell
    #4 = String             #33            // ab
    #33 = Utf8               ab
    ```

    也就是这里的指令执行过程中，是直接去取结果 `ab`而不是重新将变量加起来，最后取到变量之后执行到89 将变量存储到本地变量表，执行 astore 5, 

    查看看上面的jvm 指令，第77行和第89行都是去执行 #4 jvm 指令，所以

    ![a](./pic/jvm33.png)

    这里s5 在代码编译期间的优化，结果已经在编译期间确定为ab，s4不同的是，s1 和 s2 是变量，可能会发生变化，所以不会去StringTable 去取，而是去重新评价并 new 对象。

    * 常量池中的字符串仅仅是符号，第一次用到的时候才会变为对象
    * 利用串池的机制，来避免重复创建字符串对象
    * 字符串变量拼接的原理是 StringBuilder
    * 字符串常量拼接的原理是编译期优化
    * 可以使用 intern 方法，主动将串池中还没有的字符串对象放入到串池中

    ```java
    public class rmbConverter {
        public static void main(String[] args) {
            String x = "ab";
    
            // 堆 new String("a") new String("b") new String("ab")
            String s = new String("a") + new String("b");
    
            // 字符串对象尝试放入串池，如果串池中有，则不放入，否则放入，返回串池中内容
            String intern = s.intern();
    
            System.out.println(intern == x); // 返回true
            System.out.println(s == x); // 返回 false
            // 执行
        }
    }
    ```

    第三行一创建一个常量 字符串 "ab" 会将其放入到串池中，然后第6行新new 一个 字符s，这个时候他对象放入到了堆中，然后在9行的时候，尝试将变量s指向的常量值放入到串池中，发现串池中已经有了，所有没有放进去，然后将串池中的常量值返回到 intern，所以intern 和 x 都是串池中的常量，而s 是堆中的对象

    ![a](./pic/jvm34.png)

    在1.8版本StringTable 已经放到了堆空间中了，原因在于程序中会有大量的常量字符串，如果将StringTabel 放到了方法去中，由于这个区中java 垃圾回收不起最庸，所以当常量字符串多的时候，这里就会溢出，所以将StringTbale 放到了堆中，然后垃圾回收机制可以将不使用的常量字符串回收调

    

    StringTable 大小的设置

    ![a](./pic/jvm35.png)

    Java 1.6 中演示永久代的内存溢出

    <img src="./pic/jvm36.png" alt="a" style="zoom:50%;" />

    ---
  
* StringTable 的垃圾回收

  先来一段代码

  ```java
  /*
      -Xmx10m  : 设置堆内存最大值
      +PrintStringTableStatistics: 大于字符串表统计信息(串池中字符串数量)
      -xx:+PrintGCDetails -verbose:gc: （打印垃圾回收信息）
  
      设置： -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc
  
   */
  public class rmbConverter {
      public static void main(String[] args) {
          int i = 0;
          try {
  
          }catch (Throwable e) {
              e.printStackTrace();
          } finally {
              System.out.println();
          }
      }
  }
  ```

  执行后输出：

  ```java
  0
  Heap （垃圾回收的详细信息，以及内存占用情况）
   PSYoungGen      total 2560K, used 1283K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
    eden space 2048K, 37% used [0x00000007bfd00000,0x00000007bfdc0d70,0x00000007bff00000)
    from space 512K, 100% used [0x00000007bff00000,0x00000007bff80000,0x00000007bff80000)
    to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
   ParOldGen       total 7168K, used 114K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
    object space 7168K, 1% used [0x00000007bf600000,0x00000007bf61c808,0x00000007bfd00000)
   Metaspace       used 3163K, capacity 4496K, committed 4864K, reserved 1056768K
    class space    used 346K, capacity 388K, committed 512K, reserved 1048576K
  SymbolTable statistics: (这里就是符合表类名，方法名等)
  Number of buckets       :     20011 =    160088 bytes, avg   8.000
  Number of entries       :     12586 =    302064 bytes, avg  24.000
  Number of literals      :     12586 =    487968 bytes, avg  38.771
  Total footprint         :           =    950120 bytes
  Average bucket size     :     0.629
  Variance of bucket size :     0.632
  Std. dev. of bucket size:     0.795
  Maximum bucket size     :         6
  StringTable statistics:
  （StringTable 统计信息,StringTabel 底层的实现类似于哈希表，哈希表是数组(桶)+列表的组成）
  Number of buckets       :     60013 =    480104 bytes, avg   8.000
  60013 个桶
  Number of entries       :       834 =     20016 bytes, avg  24.000
  一个桶里面有1754个条目
  Number of literals      :       834 =     56456 bytes, avg  67.693
  字符串常量个数
  Total footprint         :           =    556576 bytes
  Average bucket size     :     0.014
  Variance of bucket size :     0.014
  Std. dev. of bucket size:     0.118
  Maximum bucket size     :         2
  ```

  上面的代码什么都没有做，但是以及有843个字符串对象了，然后修改代码

  ```java
  public class rmbConverter {
      public static void main(String[] args) {
          int i = 0;
          try {
              for (int j = 0; j < 100; j++) {
                  String.valueOf(j).intern();
                  i ++;
              }
          }catch (Throwable e) {
              e.printStackTrace();
          } finally {
              System.out.println(i);
          }
      }
  }
  ```

  然后控制台打印出来东西

  ```java
  100
  Heap
   PSYoungGen      total 2560K, used 1267K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
    eden space 2048K, 37% used [0x00000007bfd00000,0x00000007bfdc0d90,0x00000007bff00000)
    from space 512K, 96% used [0x00000007bff00000,0x00000007bff7c010,0x00000007bff80000)
    to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)
   ParOldGen       total 7168K, used 93K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
    object space 7168K, 1% used [0x00000007bf600000,0x00000007bf617440,0x00000007bfd00000)
   Metaspace       used 3152K, capacity 4496K, committed 4864K, reserved 1056768K
    class space    used 346K, capacity 388K, committed 512K, reserved 1048576K
  SymbolTable statistics:
  Number of buckets       :     20011 =    160088 bytes, avg   8.000
  Number of entries       :     12587 =    302088 bytes, avg  24.000
  Number of literals      :     12587 =    487984 bytes, avg  38.769
  Total footprint         :           =    950160 bytes
  Average bucket size     :     0.629
  Variance of bucket size :     0.632
  Std. dev. of bucket size:     0.795
  Maximum bucket size     :         6
  StringTable statistics:
  Number of buckets       :     60013 =    480104 bytes, avg   8.000
  Number of entries       :       934 =     22416 bytes, avg  24.000
  Number of literals      :       934 =     61256 bytes, avg  65.585
  Total footprint         :           =    563776 bytes
  Average bucket size     :     0.016
  Variance of bucket size :     0.016
  Std. dev. of bucket size:     0.125
  Maximum bucket size     :         2
  ```

  可以看出在 StringTable statistics: 统计信息部分以及变为了 934 个了。这个时候还是没有发生垃圾回收的

  继续修改代码

  ```java
  public class rmbConverter {
      public static void main(String[] args) {
          int i = 0;
          try {
              for (int j = 0; j < 100000; j++) {
                  String.valueOf(j).intern();
                  i ++;
              }
          }catch (Throwable e) {
              e.printStackTrace();
          } finally {
              System.out.println(i);
          }
      }
  }
  ```

  因为jvm 的配置 `-Xmx10m`的存在，这里我创建10万个字符串，必然会冲爆堆内存，StringTable 当内存一旦不够就会触发垃圾回收，执行上述的代码，然后打印信息

  ```java
  [GC (Allocation Failure) [PSYoungGen: 2048K->512K(2560K)] 2048K->592K(9728K), 0.0006876 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
  [GC (Allocation Failure) [PSYoungGen: 2560K->512K(2560K)] 2640K->660K(9728K), 0.0015921 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
  [GC (Allocation Failure) [PSYoungGen: 2560K->496K(2560K)] 2708K->684K(9728K), 0.0010287 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
  [GC (Allocation Failure) [PSYoungGen: 2544K->512K(2560K)] 2732K->716K(9728K), 0.0008899 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
  100000
  Heap
   PSYoungGen      total 2560K, used 653K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)
    eden space 2048K, 6% used [0x00000007bfd00000,0x00000007bfd23458,0x00000007bff00000)
    from space 512K, 100% used [0x00000007bff80000,0x00000007c0000000,0x00000007c0000000)
    to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)
   ParOldGen       total 7168K, used 204K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)
    object space 7168K, 2% used [0x00000007bf600000,0x00000007bf633218,0x00000007bfd00000)
   Metaspace       used 3317K, capacity 4496K, committed 4864K, reserved 1056768K
    class space    used 365K, capacity 388K, committed 512K, reserved 1048576K
  SymbolTable statistics:
  Number of buckets       :     20011 =    160088 bytes, avg   8.000
  Number of entries       :     12982 =    311568 bytes, avg  24.000
  Number of literals      :     12982 =    501136 bytes, avg  38.602
  Total footprint         :           =    972792 bytes
  Average bucket size     :     0.649
  Variance of bucket size :     0.652
  Std. dev. of bucket size:     0.807
  Maximum bucket size     :         6
  StringTable statistics:
  Number of buckets       :     60013 =    480104 bytes, avg   8.000
  Number of entries       :      2720 =     65280 bytes, avg  24.000
  Number of literals      :      2720 =    162608 bytes, avg  59.782
  Total footprint         :           =    707992 bytes
  Average bucket size     :     0.045
  Variance of bucket size :     0.044
  Std. dev. of bucket size:     0.210
  Maximum bucket size     :         3
  ```

  可以看到已经有GC信息，并且StringTable 的统计中也值有2720个字符，并不是10万个。所以上述的代码是发生了垃圾回收机制。

* StringTable 调优

  StringTable 的底层是一个哈希表，哈希表的性能和其大小密切相关的，如果哈希表的桶个数比较多，其元素相对比较分散，存放元素的时候发生碰撞的机会就比较少了，查找速度变快，反之桶的数量较少，导致存储链较长，发生哈希碰撞就会比较大概率，查找也会变慢，所以StringTable 的调优主要就是调整其桶的个数。

  准备一个包含40+万单词的文件

  然后如下程序

  ```java
  public class rmbConverter {
      public static void main(String[] args) throws IOException {
          try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("/Users/xuxliu/Ifoods/Java/leetcode/src/main/java/com/it/leetcode/huawei/StringTableTest.linux")))){
              String line = null;
              long start = System.nanoTime();
  
              while (true) {
                  line = reader.readLine();
                  if (line == null) {
                      break;
                  }
                  reader.readLine().intern();
              }
              System.out.println("cost: " + (System.nanoTime() - start)/1000000);
          }
      }
  }
  ```

  配置虚拟机参数

  `-Xms500m -Xmx500m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc -XX:StringTableSize=200000`

  执行结果

  ```java
  cost: 59
  Heap
   PSYoungGen      total 149504K, used 33429K [0x00000007b5980000, 0x00000007c0000000, 0x00000007c0000000)
    eden space 128512K, 26% used [0x00000007b5980000,0x00000007b7a256d0,0x00000007bd700000)
    from space 20992K, 0% used [0x00000007beb80000,0x00000007beb80000,0x00000007c0000000)
    to   space 20992K, 0% used [0x00000007bd700000,0x00000007bd700000,0x00000007beb80000)
   ParOldGen       total 341504K, used 0K [0x00000007a0c00000, 0x00000007b5980000, 0x00000007b5980000)
    object space 341504K, 0% used [0x00000007a0c00000,0x00000007a0c00000,0x00000007b5980000)
   Metaspace       used 3367K, capacity 4500K, committed 4864K, reserved 1056768K
    class space    used 365K, capacity 388K, committed 512K, reserved 1048576K
  SymbolTable statistics:
  Number of buckets       :     20011 =    160088 bytes, avg   8.000
  Number of entries       :     12984 =    311616 bytes, avg  24.000
  Number of literals      :     12984 =    501256 bytes, avg  38.606
  Total footprint         :           =    972960 bytes
  Average bucket size     :     0.649
  Variance of bucket size :     0.652
  Std. dev. of bucket size:     0.807
  Maximum bucket size     :         6
  StringTable statistics:
  Number of buckets       :    200000 =   1600000 bytes, avg   8.000
  Number of entries       :       914 =     21936 bytes, avg  24.000
  Number of literals      :       914 =     61768 bytes, avg  67.580
  Total footprint         :           =   1683704 bytes
  Average bucket size     :     0.005
  Variance of bucket size :     0.005
  Std. dev. of bucket size:     0.068
  Maximum bucket size     :         2
  ```

  以上最重要的的打印结果

  ：cost: 59 花费时间在0.05秒左右

  StringTable 中有20000个桶，读取40+万个单词，差不多就是仅仅每个桶中有2个单词，基本不会哈希碰撞，读取的速度也很快。

  如果默认不加参数  `-XX:StringTableSize=200000`

  再执行一次程序，则打印结果为：

  ```java
  cost: 69
  Heap
   PSYoungGen      total 149504K, used 33429K [0x00000007b5980000, 0x00000007c0000000, 0x00000007c0000000)
    eden space 128512K, 26% used [0x00000007b5980000,0x00000007b7a256d0,0x00000007bd700000)
    from space 20992K, 0% used [0x00000007beb80000,0x00000007beb80000,0x00000007c0000000)
    to   space 20992K, 0% used [0x00000007bd700000,0x00000007bd700000,0x00000007beb80000)
   ParOldGen       total 341504K, used 0K [0x00000007a0c00000, 0x00000007b5980000, 0x00000007b5980000)
    object space 341504K, 0% used [0x00000007a0c00000,0x00000007a0c00000,0x00000007b5980000)
   Metaspace       used 3366K, capacity 4500K, committed 4864K, reserved 1056768K
    class space    used 365K, capacity 388K, committed 512K, reserved 1048576K
  SymbolTable statistics:
  Number of buckets       :     20011 =    160088 bytes, avg   8.000
  Number of entries       :     12984 =    311616 bytes, avg  24.000
  Number of literals      :     12984 =    501256 bytes, avg  38.606
  Total footprint         :           =    972960 bytes
  Average bucket size     :     0.649
  Variance of bucket size :     0.652
  Std. dev. of bucket size:     0.807
  Maximum bucket size     :         6
  StringTable statistics:
  Number of buckets       :     60013 =    480104 bytes, avg   8.000
  Number of entries       :       914 =     21936 bytes, avg  24.000
  Number of literals      :       914 =     61768 bytes, avg  67.580
  Total footprint         :           =    563808 bytes
  Average bucket size     :     0.015
  Variance of bucket size :     0.015
  Std. dev. of bucket size:     0.123
  Maximum bucket size     :         2
  ```

  耗费时间变多了，而且默认桶大小为 `60013` 个

  然后我继续将`StringTableSize` 调小一点，比如说200，那么久出错了

  ```javascript
  StringTable size of 200 is invalid; must be between 1009 and 2305843009213693951
  ```

  那就 1009。

  ```java
  cost: 116
  Heap
   PSYoungGen      total 149504K, used 33429K [0x00000007b5980000, 0x00000007c0000000, 0x00000007c0000000)
    eden space 128512K, 26% used [0x00000007b5980000,0x00000007b7a256d0,0x00000007bd700000)
    from space 20992K, 0% used [0x00000007beb80000,0x00000007beb80000,0x00000007c0000000)
    to   space 20992K, 0% used [0x00000007bd700000,0x00000007bd700000,0x00000007beb80000)
   ParOldGen       total 341504K, used 0K [0x00000007a0c00000, 0x00000007b5980000, 0x00000007b5980000)
    object space 341504K, 0% used [0x00000007a0c00000,0x00000007a0c00000,0x00000007b5980000)
   Metaspace       used 3357K, capacity 4500K, committed 4864K, reserved 1056768K
    class space    used 365K, capacity 388K, committed 512K, reserved 1048576K
  SymbolTable statistics:
  Number of buckets       :     20011 =    160088 bytes, avg   8.000
  Number of entries       :     12984 =    311616 bytes, avg  24.000
  Number of literals      :     12984 =    501256 bytes, avg  38.606
  Total footprint         :           =    972960 bytes
  Average bucket size     :     0.649
  Variance of bucket size :     0.652
  Std. dev. of bucket size:     0.807
  Maximum bucket size     :         6
  StringTable statistics:
  Number of buckets       :      1009 =      8072 bytes, avg   8.000
  Number of entries       :       918 =     22032 bytes, avg  24.000
  Number of literals      :       918 =     61992 bytes, avg  67.529
  Total footprint         :           =     92096 bytes
  Average bucket size     :     0.910
  Variance of bucket size :     0.855
  Std. dev. of bucket size:     0.925
  Maximum bucket size     :         5
  ```

  结果是变慢了。

  * 优化1所以当字符串常量比较多的时候可以将StringTabel (-XX:StringTableSize=桶个数)设置大点，那么程序执行的速度就能快点了。
  * 考虑将字符串对象放入字符池子中，就可以优化重复的存在，以及存在在字符池中的字符串就可以直接使用了，而不是在创建重复的字符串(新创建的字符串对象会放入到堆内存中)

  ---

  * 直接内存

  ![a](./pic/jvm3.png)

  如上图，上图中并没有直接内存的地方。那么什么是直接内存呢？它并不是jvm 的管理内存，而是操作系统物理机的内存，

  **Direct Memory**

  	* 常见于 `NIO` 操作时候，用于数据缓冲区
  	* 分配回收成本较高(因为属于操作系统部分，不受jvm管理所以会比较高)，但读写性能高(系统内存，操作系统中的文件更加高效)
  	* 不受`jvm`内存回收管理

  ![a](./pic/jvm37.png)

  ![a](./pic/jvm38.png)

  以上两段代码，out的io读取文件，和使用直接内存读取文件(调用`allocateDirect`方法)的代码，当调用使用之间内存的方法的时候，读取文件话费的时间会少很多。使用直接内存花费更少的时间的原因如下分析:

  使用`IO` 的读写过程：

  <img src="./pic/jvm39.png" alt="a" style="zoom:50%;" />

  `Java` 程序读文件的时候，必须调用系统的接口(System 部分)，在内存这边的操作当程序到达内核态的时候，就到达内存这边 ，首先从磁盘文件中读取，然后 在系统内存中划出一片缓冲区，将文件缓冲在这里，在这片系统缓冲区中是不能执行`Java` 代码的，然后在`JVM` 管理的堆内存中在开辟一块内存，将系统缓冲区中的内存读到`Java` 的缓冲区，然后在到达Java代码区，

  所以上述的过程会出现2块缓冲区，在2块缓冲区之间存在一个数据复制的过程。

  使用 `DirectBuffer` 的读取过程

  <img src="./pic/jvm40.png" alt="a" style="zoom:50%;" />

  在调用方法  `allocateDirect`的时候在操作系统划分一块直接内存，这块内存`Java` 代码可以直接访问，也就是在块直接内存`Java` 代码和系统都可以访问的区域。这里就不会出现数据的复制等操作，然后读取速度就快加快很多。

  `Direct Memory` 是不受`Jvm`的垃圾回收，那么会出现内存溢出的问题么？

  <img src="./pic/jvm41.png" alt="a" style="zoom:50%;" />

  显然会的，那么它是如何能够正确回收内存呢？通过 设置一个空指针就可以回收直接内存

  <img src="./pic/jvm42.png" alt="a" style="zoom:50%;" />

  

  

  在`jvm` 中是通过`Unsafe` 的类去对之间内存进行释放的，上面的代码演示了`jvm`的执行过程，在执行

  `unsafe.allocateMemoty(_1GB)` 返回的long 型是直接内存的地址。然后释放直接内存执行 `unsafe.freeMemoty(base)` 查看`DirectByteBuffer` 源码中就能够看到和上述代码相似的代码。

  **使用Unsafe 对象完成之间内存的分配回收，并且回收需要主动调用 freeMemory 方法，**

  **ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来检测 ByteBuffer 对象， 一旦 ByteBuffer 对象呗垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放之间内存**

  

  

  

  

  

  

  

  
  
  