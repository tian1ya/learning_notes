### 什么是进程

一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个最小单位

### 什么是线程？

线程是操作系统能够进行运算调度的最小单位。被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。

### 为什么要使用多线程？

与进程相比，线程的创建和切换开销更小。 由于启动一个新的进程必须给这个线程分配独立的地址空间，建立许多数据结构来维护线程代码段、数据段等信息，而运行于同一个进程内的线程共享代码段、数据段，线程的启动或切换的开销就比进程要少很多。同时多线程在数据共享方面效率非常高。

多CPU或多核心计算机本身就具有执行多线程的能力。 如果使用单个线程，将无法重复利用计算机资源，造成资源的巨大浪费。**因此在多CPU计算机上使用多线程能提高CPU的利用率。**

### 什么是线程安全？

当多个线程访问同一个对象时，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的

### 为何要使用线程同步？

Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。

### 如何确保线程安全？

* 加锁
* 线程安全的类

### 什么是原子操作？

操作均作为单一的、不可分割的原子操作完成。

### Java内存模型是什么？

Java中所有变量都储存在主存中，对于所有线程都是共享的（因为在同一进程中），每个线程都有自己的工作内存或本地内存(Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，而线程之间无法相互直接访问，变量传递均需要通过主存完成，但是在程序内部可以互相调用(通过对象方法)，所有线程间的通信相对简单，速度也很快。

### Java中堆和栈有什么不同？

栈：在**函数**中定义的基本类型的变量和对象的引用变量都是在函数的栈内存中分配。

堆：堆内存用于存放由new创建的对象和数组。

从通俗化的角度来说，**堆是用来存放对象的，栈是用来存放执行程序的**

### JVM中哪个参数是用来控制线程的栈堆栈小的

-Xss参数用来控制线程的堆栈大小。

### 什么是竞态条件？你怎样发现和解决竞争？

**当两个线程竞争同一资源时，如果对资源的*访问顺序敏感***，就称存在竞态条件。

在临界区中使用适当的同步就可以避免竞态条件。

界区实现方法有两种，一种是用synchronized，一种是用Lock显式锁实现。

### 线程安全的级别

#### 不可变

不可变的对象一定是线程安全的，并且永远也不需要额外的同步。

> Java类库中大多数基本数值类如Integer、String和BigInteger都是不可变的。

#### 无条件的线程安全

由类的规格说明所规定的约束在对象被多个线程访问时仍然有效，不管运行时环境如何排列，线程都不需要任何额外的同步。

> 如 Random 、ConcurrentHashMap、Concurrent集合、atomic

#### 有条件的线程安全

有条件的线程安全类对于单独的操作可以是线程安全的，但是某些操作序列可能需要外部同步。

> 有条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的迭代器

#### 非线程安全(线程兼容)

线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用。

> 如ArrayList HashMap

### 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？

线程调度器是一个操作系统服务，**它负责为Runnable状态的线程分配CPU时间**。一旦创建一个线程并启动它，它的执行便依赖于线程调度器的实现。

时间分片是指将**可用的CPU时间分配给可用的Runnable线程**的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。

线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择。

### 在多线程中，什么是上下文切换(context-switching)？

单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）。

操作系统中，CPU时间分片切换到另一个就绪的线程，则需要**保存当前线程的运行的位置，同时需要加载需要恢复线程的环境信息。**

### 用户线程和守护线程有什么区别？

**守护线程都是为JVM中所有非守护线程的运行提供便利服务**： 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。

User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。

### 如何创建守护线程？以及在什么场合来使用它？

任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。

**守护线程相当于后台管理者 比如 : 进行内存回收,垃圾清理等工作**



### 

