#### Mysql 是如何工作的

![1668517420594](.\调优.assets\1668517420594.png)

当查询一条`sql` 的时候

1. 先去缓存中查询看是否能够命中缓存，但是在`8.0` 之后缓存被废弃掉了，维护缓存的收益并不高
2. 缓存命中的话，直接返回查询结果，如果没有命中则进入分析器
3. 分析器类似于一个编译器，做`sql`语法、词法分析
4. 经过分析器后，可以知道`sql` 要干什么，但是怎么干，怎么更高效的干，是需要优化器
5. 优化器对`sql`进行性能优化，一句`sql` 的执行是可以有多种方式的，优化器会选择代价最小的那种方式去执行
6. 执行调用引擎的接口，执行`sql`



#### 索引数据结构

![1668425071151](.\调优.assets\1668425071151.png)

是`Mysql` 索引的数据结构`B+树`，其中`B` 指的是`Balance` ，它是一种平衡树，同时也满足搜索树，右子树的节点值均大于父亲节点值，左边均小于。叶子几点直接是一个链表。

每一个叶子节点均是一个`多路搜索树`，就是有多个子节点。

#### 聚集索引和非聚集索引

![1668426121844](.\调优.assets\1668426121844.png)



聚集索引/唯一索引，是只在`B+`树的叶子节点存储的是数据表中的一行数据，而非聚集索引/普通索引/二级索引只的是在叶子节点存储的是索引以及唯一索引，所以在通过非聚集索引查询数据的时候，是先找到非聚集索引中的聚集索引，然后再查询一次聚集索引获取到聚集索引叶子节点中的每一行数据，拿到最终结果。

其中叶子节点是双向列表，且这些值均是排好序的，例如我要获取`9<=value<=90`的数据，此时从row8获取到一个 `value=9` 的数据，那么继续获取`value > 9` 的数据，这个时候是不需要在回到节点，然后从节点在到叶子节点，可以直接从`value=9` 顺着指针拿到下一个值，一直往下，直到拿到一个`value=91`的值，这时条件不满足，退出查询。**退出查询的条件是查询到不满足条件的那行，而不是刚刚查找到满足条件的所有数据**。

上面的集聚所有和非聚集索引画在同一个树上完全是为了方便，说明聚集和非聚集索引长的样子。实际上一个索引一颗树。



上面的可以看到非聚集索引的的`IO`效率会更高，因为叶子节点存储的值要比聚集索引的更少。



上面的说法中还有一个概念问题，在每个叶子节点中存储的是`页`，在`页` 中存储的是`数据行`

#### 优化例子

```sql
-- 如果没有数据库，创建数据库，如果不想创建数据库，注意修改连接配置参数
create database bear;
use bear;

CREATE TABLE `order_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `period` int(11) NOT NULL COMMENT '账期月份',
  `amount` decimal(10,4) NOT NULL COMMENT '金额',
  `user_name` varchar(20) NOT NULL COMMENT '下单人',
  `phone` varchar(11) NOT NULL COMMENT '手机号',
  `created` datetime NOT NULL DEFAULT '1000-01-01 00:00:00' ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  `creator` varchar(20) NOT NULL COMMENT '创建人',
  `modified` datetime NOT NULL DEFAULT '1000-01-01 00:00:00' ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `modifier` varchar(20) NOT NULL COMMENT '修改人',
  PRIMARY KEY (`id`),
  KEY `idx_period` (`period`),
  KEY `idx_modified` (`modified`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

-- 需求
-- 按月导出账单
-- 例如说按照6月、7月将数据导出，用于财物对账

select count(*) from order_info
-- 100000

explain select * from order_info where period=201912 order by modified desc limit 0, 10
```

![1668519704293](.\调优.assets\1668519704293.png)

mysql 预估查询198行，过滤出来 %5的数据返回，这仅仅是抽样的结果预估的
实际需要检索多少行是不知道的
执行时间 0.099s

```sql
explain select * from order_info force index (idx_period) where period=201912 order by modified desc limit 0, 10
-- 使用 force index
```

![1668519754496](.\调优.assets\1668519754496.png)

上面之所以选错索引，是因为`mysql` 在预估的时候预估使用`modified` 可以达到最好的检索性能。

 执行时间 0.036，第一中方式选择错了索引，但是第二种方式产生了排序，任然不是最优的。

如何继续优化去掉`另外的排序`



但是使用`force index` 强制走指定索引



