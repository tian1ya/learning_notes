#### 字符串最后一个单词的长度

> 计算字符串最后一个单词的长度，单词以空格隔开。
>
> 输入一行，代表要计算的字符串，非空，长度小于5000。
>
> 输出一个整数，表示输入字符串最后一个单词的长度。

```java
public static void main(String[] args) {
  Scanner scanner = new Scanner(System.in);
  String string = scanner.nextLine();

  if (string.length() == 0 || string == null) {
    System.out.println(-1);
  } else {
    String[] str = string.split(" ");
    System.out.println(str[str.length - 1].length());
  }
}
```

####  计算字符个数

> 写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字母，然后输出输入字符串中该字母的出现次数。不区分大小写。
>
> 第一行输入一个由字母和数字以及空格组成的字符串，第二行输入一个字母。
>
> 输出输入字符串中含有该字符的个数。
>
> ```java
> import java.util.Scanner;
> 
> public class Test {
> 
>     public static void main(String[] args) {
>         Scanner scanner = new Scanner(System.in);
>         String line = scanner.nextLine().toUpperCase();
> 
>         String word = scanner.nextLine().toUpperCase();
> 
>         String replacedLine = line.replace(word, "");
>         System.out.println(line.length() - replacedLine.length());
>     }
> }
> ```

#### 明明的随机数

> 完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。
>
> 输入可能有多组数据。每组数据都包括多行，第一行先输入随机整数的个数N，接下来的N行再输入相应个数的整数。具体格式请看下面的"示例"

```java
import java.util.Scanner;
import java.util.TreeSet;

public class Test {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){

            TreeSet<Integer> set= new TreeSet<>();
            int n=sc.nextInt();
            if(n>0){
                for(int i=0;i<n;i++){
                    set.add(sc.nextInt());
                }
            }
            for(Integer i:set){
                System.out.println(i);
            }
        }
    }
}
```

#### 字符串分隔

> •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；
> •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。
>
> 连续输入字符串(输入多次,每个字符串长度小于100)

```java
import java.util.Scanner;

public class Test {

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String s = sc.nextLine();
            if(s.length()%8 !=0 )
                s = s + "00000000";

            while(s.length()>=8){
                System.out.println(s.substring(0, 8));
                s = s.substring(8);
            }
        }
    }
}
```

#### 进制转换

> 写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。
>
> 输出该数值的十进制字符串。不同组的测试用例用\n隔开。

```java
import java.util.Scanner;

public class Test {

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String s = sc.nextLine();
            if(s.length()%8 !=0 )
                s = s + "00000000";

            while(s.length()>=8){
                System.out.println(s.substring(0, 8));
                s = s.substring(8);
            }
        }
    }
}
```

#### 质数因子

> 功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子(能整除给定正整数的质数))
>
> （重复的也要列举）（如180的质因子为2 2 3 3 5 ）
>
> 最后一个数后面也要有空格
>
> 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。

####  取近似值

> 写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。
>
> ```java
> import java.util.ArrayList;
> import java.util.Scanner;
> public class Main {
>     public static void main(String[] args) {
>         Scanner scan = new Scanner(System.in);
>         while(scan.hasNext()){
>             double d = scan.nextDouble();
>             int dint = (int)d;
>             if((d-dint)>=0.5 && (d-dint)<1)
>                 dint++;
>             System.out.println(dint);
>         }
>     }
> }
> ```

#### 合并表记录

> 数据表记录包含表索引和数值（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。
>
> ```java
> import java.util.Iterator;
> import java.util.Map;
> import java.util.Scanner;
> import java.util.TreeMap;
>  
> public class Main {
>     public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         while (sc.hasNext()) {
>             Map<Integer, Integer> map = new TreeMap<Integer, Integer>();
>             int n = sc.nextInt();
>             for (int i = 0; i < n; i++) {
>                 int s=sc.nextInt();
>                 int value=sc.nextInt();
>                 if (map.containsKey(s)) {
>                     map.put(s, map.get(s) + value);
>                 } else
>                     map.put(s, value);
>             }
>             for (Integer key : map.keySet()) {
>                 System.out.println(key + " " + map.get(key));
>             }
>         }
>     }
> }
> ```

####  提取不重复的整数

> 输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。
>
> 保证输入的整数最后一位不是0。
>
> ```java
> import java.util.*;
>  
> public class Main{
>      public static void main(String[] args){
>         Scanner scan = new Scanner(System.in);
>         String str = scan.nextLine();
>         StringBuffer sb = new StringBuffer(str);
>         Set s = new HashSet();
>         sb.reverse();//字符串反转
>         for(int i = 0;i<sb.length();i++){
>            if(s.add(sb.substring(i,i+1))){//set不允许重复添加相同的元素
>                System.out.print(sb.substring(i,i+1));
>            }
>         }
>     }
> }
> ```

#### 字符个数统计

> 编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次
>
> 例如，对于字符串abaca而言，有a、b、c三种不同的字符，因此输出3。
>
> ```
> 输入一行没有空格的字符串。
> 输出范围在(0~127)字符的个数。
> ```
>
> ```java
> import java.util.*;
> public class Main{
>     public static void main(String[] args) {
>         Scanner sc=new Scanner(System.in);
>         while(sc.hasNext()){
>             String str=sc.nextLine();
>             char[] ch=str.toCharArray();
>             HashSet<Character> set=new HashSet<Character>();
>             for (int i = 0; i < ch.length; i++) {
>                 set.add(ch[i]);
>             }
>             System.out.println(set.size());
>         }
>         sc.close();
>     }
> }
> ```

#### 数字颠倒

> 输入一个整数，将这个整数以字符串的形式逆序输出
>
> 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001
>
> ```java
> import java.util.*;
> public class Main {
>     public static void main(String[] args){
>         Scanner scan = new Scanner(System.in);
>         String str = scan.nextLine();
>         StringBuffer sb = new StringBuffer(str);
>         sb.reverse();
>         System.out.println(sb.toString());
>     }
> }
> ```

#### 字符串反转

> 接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）
>
> ```java
> import java.util.*;
> public class Main {
>     public static void main(String[] args){
>         Scanner scan = new Scanner(System.in);
>         String str = scan.nextLine();
>         StringBuffer sb = new StringBuffer(str);
>         sb.reverse();
>         System.out.println(sb.toString());
>     }
> }
> ```

#### 句子逆序

> 将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”
> 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符
>
> ```java
> import java.util.*;
> public class Main {
>     public static void main(String[] args){
>         Scanner scan = new Scanner(System.in);
>         String str = scan.nextLine();
>         StringBuffer sb = new StringBuffer(str);
>         sb.reverse();
>         System.out.println(sb.toString());
>     }
> }
> ```

####  字符串排序

> 给定n个字符串，请对n个字符串按照字典序排列。
>
> 输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。
>
> ```java
> import java.util.Arrays;
> import java.util.Scanner;
> public class Main {
>     public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         int num = sc.nextInt();
>         String [] ss = new String[num];
>         for (int i = 0; i < num; i++) {
>             ss[i]=sc.next();
>         }
>         Arrays.sort(ss);
>         for (int i = 0; i < ss.length; i++) {
>             System.out.println(ss[i]);
>         }
>     }
> }
> ```

####  求int型数据在内存中存储时1的个数

> 输入一个int型的正整数，计算出该int型数据在内存中存储是1的个数。
>
> ```
> 输入一个整数（int类型）
> 这个数转换成2进制后，输出1的个数
> ```
>
> ```java
> import java.util.Scanner;
>  
> public class Main {
>     public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         int num = sc.nextInt();
>         String s = Integer.toBinaryString(num);
>         num=0;
>         for (int i = 0; i < s.length(); i++) {
>             if(s.charAt(i)=='1'){
>                 num++;
>             }
>         }
>         System.out.println(num);
>     }
> }
> ```

####  [难]购物单

> ```
> 输入的第 1 行，为两个正整数，用一个空格隔开：N m
> 
> （其中 N （ <32000 ）表示总钱数， m （ <60 ）为希望购买物品的个数。）
> 
> 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q
> 
> （其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）
> ```

> ```java
> import java.util.*;
> 
> public class Main {
>     private static int[][] remember;//用来存放计算过的子问题
>     public static void main(String[] args) {
>         Scanner in = new Scanner(System.in);
>         int N = in.nextInt();
>         int m = in.nextInt();
>         remember = new int[m][N];
>         Map<Integer,good> map = new HashMap<>();
>         int id;
>         int price;
>         int importance;
>         int belong;
>         for(int i=0;i<m;i++){
>             id = i+1;
>             price = in.nextInt();
>             importance = in.nextInt();
>             belong = in.nextInt();
>             if (belong==0){//主件添加到map中
>                 map.put(id,new good(price,importance));
>             }else {//附件添加到主件的属性中
>                 map.get(belong).addGood(new good(price,importance));
>             }
>         }
>         in.close();
>         List<Map.Entry<Integer,good>> list = new ArrayList<>(map.entrySet());//list中只含主件，附件都在主件属性中
>         System.out.println(solve(list,N));
>     }
> 
>     private static int solve(List<Map.Entry<Integer,good>> list,int N){//递归
>         if(list.size()==0) return 0;
>         if(N==0) return 0;
>         good g = list.get(0).getValue();
>         int id = list.get(0).getKey();
>         if(remember[id-1][N-1]!=0) return remember[id-1][N-1];
>         list.remove(0);
>         if(g.price>N){//不够钱买
>             return solve(list,N);
>         }else{
>             //只买主件
>             int max = g.value+solve(copyList(list),N-g.price);
>             //买主件+附件一
>             if(g.good1!=null && N>=g.price+g.good1.price){
>                 max = Math.max(max,g.value+g.good1.value+solve(copyList(list),N-g.price-g.good1.price));
>             }
>             //买主件+附件二
>             if (g.good2!=null && N>=g.price+g.good2.price){
>                 max = Math.max(max,g.value+g.good2.value+solve(copyList(list),N-g.price-g.good2.price));
>             }
>             //买主件+附件一+附件二
>             if(g.good1!=null && g.good2!=null && N>=g.price+g.good1.price+g.good2.price){
>                 max = Math.max(max,g.value+g.good1.value+g.good2.value+solve(copyList(list),N-g.price-g.good1.price-g.good2.price));
>             }
>             //不买主件
>             max = Math.max(max,solve(copyList(list),N));
>             remember[id-1][N-1] = max;
>             return max;
>         }
>     }
> 
>     static class good{
>         int price;
>         int value;
>         good good1;
>         good good2;
>         public good(int price, int importance) {
>             this.price = price;
>             this.value = price*importance;
>         }
>         public void addGood(good good){//为主件添加附件
>             if (good1==null){
>                 good1 = good;
>             }else if(good2==null){
>                 good2 = good;
>             }
>         }
>     }
> 
>     private static List copyList(List<Map.Entry<Integer,good>> list){//返回list的复制
>         List<Map.Entry<Integer,good>> resultList = new ArrayList<>();
>         resultList.addAll(list);
>         return resultList;
>     }
> }
> ```

#### 坐标移动

> 开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。
>
> 输入：
>
> 合法坐标为A(或者D或者W或者S) + 数字（两位以内）
>
> 坐标之间以;分隔。
>
> 非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。
>
> 下面是一个简单的例子 如：
>
> A10;S20;W10;D30;X;A1A;B10A11;;A10;
>
> 处理过程：
>
> 起点（0,0）
>
> \+  A10  = （-10,0）
>
> \+  S20  = (-10,-20)
>
> \+  W10 = (-10,-10)
>
> \+  D30 = (20,-10)
>
> \+  x  = 无效
>
> \+  A1A  = 无效
>
> \+  B10A11  = 无效
>
> \+ 一个空 不影响
>
> \+  A10 = (10,-10)
>
> 结果 （10， -10）
>
> ```java
> import java.util.*;
> public class Main{
>     
>     public static void main(String[] args){
>         Scanner sc=new Scanner(System.in);
>         while(sc.hasNext()){
>             String str=sc.nextLine();
>             String[] A=str.split(";");
>             int x=0,y=0;
>             for(String string:A){
>                 if(string.charAt(0)=='D' && string.substring(1).matches("[0-9]+"))
>                     x+=Integer.parseInt(string.substring(1));
>                 
>                 if(string.charAt(0)=='W' && string.substring(1).matches("[0-9]+"))
>                     y+=Integer.parseInt(string.substring(1));
>                 
>                 if(string.charAt(0)=='S' && string.substring(1).matches("[0-9]+"))
>                     y-=Integer.parseInt(string.substring(1));
>                 
>                 if(string.charAt(0)=='A' && string.substring(1).matches("[0-9]+"))
>                     x-=Integer.parseInt(string.substring(1));
>               
>             }
>             System.out.println(x+","+y);
>         }
>         sc.close();
>     } 
> }
> ```

#### [还好]识别有效的IP地址和掩码并进行分类统计

> 请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。
>
> 所有的IP地址划分为 A,B,C,D,E五类
>
> A类地址1.0.0.0~126.255.255.255;
>
> B类地址128.0.0.0~191.255.255.255;
>
> C类地址192.0.0.0~223.255.255.255;
>
> D类地址224.0.0.0~239.255.255.255；
>
> E类地址240.0.0.0~255.255.255.255
>
> 私网IP范围是：
>
> 10.0.0.0～10.255.255.255
>
> 172.16.0.0～172.31.255.255
>
> 192.168.0.0～192.168.255.255
>
> 子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）
>
> 注意二进制下全是1或者全是0均为非法
>
> 注意：
>
> \1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时可以忽略
>
> \2. 私有IP地址和A,B,C,D,E类地址是不冲突的
>
> 输入描述:
>
> ```
> 多行字符串。每行一个IP地址和掩码，用~隔开。
> ```
>
> 输出描述:
>
> ```
> 统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。
> ```

```java
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {

	public static void main(String[] args){
		Scanner scanner = new Scanner(System.in);
		int typeA = 0;
		int typeB = 0;
		int typeC = 0;
		int typeD = 0;
		int typeE = 0;
		int errorIpOrMaskCode = 0;
		int privIp = 0;
		
		while (scanner.hasNext()) {
			String ipt = scanner.nextLine();
			String[] ipAndMaskCode = ipt.split("~");
			String ip = ipAndMaskCode[0];
			String maskCode = ipAndMaskCode[1];
			// 判断格式
			if (!isValidFormat(ip) || !isValidFormat(maskCode)) {
				errorIpOrMaskCode++;
				continue;
			}

			// 判断掩码是否错误
			if (!validMaskCode(maskCode)) {
				errorIpOrMaskCode++;
				continue;
			}

			// 判断ip类别
			String fnStr = ip.substring(0, ip.indexOf("."));
			int fn = Integer.valueOf(fnStr);
			if (fn >= 1 && fn < 127) {
				// A
				typeA++;
			} else if (fn >= 128 && fn < 192) {
				// B
				typeB++;
			} else if (fn >= 192 && fn < 224) {
				// C
				typeC++;
			} else if (fn >= 224 && fn < 240) {
				// D
				typeD++;
			} else if (fn >= 240 && fn <= 255) {
				// E
				typeE++;
			}

			// 判断是否是私网IP
			String ipSubStr = ip.substring(ip.indexOf(".") + 1);
			String snStr = ipSubStr.substring(0, ipSubStr.indexOf("."));
			int sn = Integer.valueOf(snStr);
			if (fn == 10 || (fn == 172 && sn >= 16 && sn <= 31) || (fn == 192 && sn == 168)) {
				privIp++;
			}
//			System.out.printf("%d %d%n", fn, sn);

		}
		scanner.close();

		System.out.printf("%d %d %d %d %d %d %d%n", typeA, typeB, typeC, typeD, typeE, errorIpOrMaskCode, privIp);

	}

	/**
	 * 判断ip和掩码是否是xxx.xxx.xxx.xxx格式Ø
	 * 
	 * @param ip
	 * @return
	 */
	private static boolean isValidFormat(String ip) {
		boolean res = true;
		if (ip == null || "".equals(ip))
			return false;
		Pattern pattern = Pattern.compile("^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$");
		Matcher matcher = pattern.matcher(ip);
		
		if (matcher.matches()) {
			String[] nums = ip.split("\\.");
			for (String num : nums) {
				int n = Integer.valueOf(num);
				if (n < 0 || n > 255) {
					res = false;
					break;
				}
			}
		} else {
			res = false;
		}
		
		return res;
	}

	/**
	 * 判断掩码是否是前面全为1后面全为0 的格式
	 * 
	 * @param maskCode
	 * @return
	 */
	private static boolean validMaskCode(String maskCode) {
		boolean res = true;
		String[] nums = maskCode.split("\\.");
		StringBuilder sb = new StringBuilder();
		for (String num : nums) {
			int n = Integer.valueOf(num);
			sb.append(binaryString(n));
		}
		int firstIndexOf0 = sb.indexOf("0");
		int lastIndexOf1 = sb.lastIndexOf("1");
		if (firstIndexOf0 < lastIndexOf1) {
			res = false;
		}
		return res;
	}
	
	/**
	 * 将整数转成对应的八位二进制字符串
	 * @param num
	 * @return
	 */
	private static String binaryString(int num) {
		StringBuilder result = new StringBuilder();
		int flag = 1 << 7;
		for (int i = 0; i < 8; i++) {
			int val = (flag & num) == 0 ? 0 : 1;
			result.append(val);
			num <<= 1;
		}
		return result.toString();
	}
}
```

#### 简单错误记录

> 开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。
>
> 处理：
>
> 1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是**错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是”相同“的错误记录。**
>
> 2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；
>
> 3、 输入的文件可能带路径，记录文件名称不能带路径。
>
> 4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准
>
> 输入描述:
>
> ```
> 每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。
> ```
>
> 输出描述:
>
> ```
> 将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开，如：
> ```

```java
//纯粹的考代码实现能力
//记录个数，故使用Map，不需要排序故使用HashMap，根据题意是要循环输出，而且提交一次会有测试用例提示，需要按照输入顺序输出，故使用LinkedHashMap
//在输出的时候，题目的意思是循环八个，但问题是必须记录全部错误个数，否则刚记录完后弹出了，错误数就对不上了，跟操作系统里的缺页有那么点相似。
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		Map<String, Integer> map=new LinkedHashMap<String, Integer>();
		while(sc.hasNext()){
			String str=sc.next();
			int linenum=sc.nextInt();
			String[] arr=str.split("\\\\");  //根据\切割
			String s=arr[arr.length-1];
			if(s.length()>16)  //截取
				s=s.substring(s.length()-16);
			String key=s+" "+linenum;
			int value=1;
			if(map.containsKey(key))
				map.put(key, map.get(key)+1);
			else {
				map.put(key, value);
			}
		}
		int count=0;
		for(String string:map.keySet()){
			count++;
			if(count>(map.keySet().size()-8)) //输出最后八个记录
			    System.out.println(string+" "+map.get(string));
		}
	}
}
```

####  [有点难度：正则表达式]密码验证合格程序

> 密码要求:
>
> 1.长度超过8位
>
> 2.包括大小写字母.数字.其它符号,以上四种至少三种
>
> 3.不能有相同长度大于2的子串重复
>
> ```
> 如果符合要求输出：OK，否则输出NG
> ```

```java
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println(password(sc.next()));
	}
	
	public static String password(String str) {
		if (str == null || "".equals(str))
			return str;
		char[] nums = str.toCharArray();
		StringBuilder sb = new StringBuilder();
		for (char c : nums) {
			if (c >= 'a' && c <= 'z') {
				if (c == 's' || c == 'v'|| c == 'y' || c == 'z')
          sb.append((c - 'a') / 3 + 1);
				else 
					sb.append((c - 'a') / 3 + 2);
			} else if (c >= 'A' && c <= 'Z') {
				if (c == 'Z')
					sb.append('a');
				else
					sb.append((char)(c + 'a' - 'A' + 1));
			} else {
                sb.append(c);
            }
		}
		return sb.toString();
	}
	
}
```

####  汽水瓶

> 有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？
>
> 输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。

```java
// f(n)=n/3 + f(n%3+n/3)，貌似递归次数更少。
// n/3是能直接换到的汽水数，n%3+n/3是新换到的汽水瓶子+上次换剩下的

import java.util.*;

public class Main {

	public static int f(int n) {
		if (n == 1)
			return 0;
		if (n == 2)
			return 1;
		return n / 3 + f(n % 3 + n / 3);
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int num = sc.nextInt();
			if (num != 0) {
				System.out.println(f(num));
			}
		}
		sc.close();
	}
}



// 数学推导方法
public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int num = sc.nextInt();
			if (num != 0) {
				System.out.println(num/2);
			}
		}
		sc.close();
	}
```

#### 删除字符串中出现次数最少的字符

> 实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。
>
> 注意每个输入文件有多组输入，即多个字符串用回车隔开
>
> ```
> 字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){
            
        String string=sc.nextLine();
        char[] A=string.toCharArray();
        Map<Character,Integer> m=new LinkedHashMap<Character,Integer>();
      
        
        for(char c:A){
            if(!m.containsKey(c)){
                 m.put(c,1);
                
            }else{
                m.put(c,m.get(c)+1);
               
            }     
        }
        Collection<Integer> al=m.values();
        int index=Collections.min(al);
      StringBuffer sb=new StringBuffer("");
        for(char c:A){
            if(m.get(c)!=index)
                sb.append(c);
        }   
          System.out.println(sb.toString());    
       }
    }
}
```

####  合唱队

> 计算最少出列多少位同学，使得剩下的同学排成合唱队形
>
> 说明：
>
> N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。
> 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK，  则他们的身高满足存在i（1<=i<=K）使得T1<T2<......<Ti-1<Ti>Ti+1>......>TK。
>
> 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。
>
> **注意不允许改变队列元素的先后顺序**
>
> **请注意处理多组输入输出！**
>
> > 动态规划；（动态规划之最长上升子序列的引用与改进）
> >
> > 最少几个同学出列==最多几个同学留下来
> >
> > i从左边开始，求最长上升子序列inc；
> >
> > j从右边开始，求最长下降子序列dec；
> >
> > 相当于每个元素都有自己的左边最长上升子序列和右边的最长下降子序列，
> >
> > inc[i] + dec[i]相加扣除重复计算自身的1就是留下的最长合法序列；
> >
> > 最少多少个同学出列的结果就是v.size()减最长合法序列；

```java
/*   借鉴顶楼兄弟的思路，但表述稍许不清，所谓递增计数，实际上就是以当前值为结尾的序列的最长递增子序列长度，
 比如以197结尾的序列中，最长递增子序列为150，160，197，故递增计数为3，由于三个数并不相邻，故称其为“子串”不妥。
     所谓“递增计数”就是用动态规划求最长递增子序列中的“dp”:
     dp[i]={max(dp[j])+1,j<i且a[j]<a[i]},
     翻译成汉字：以a[i]结尾的序列的最长递增子序列长度，等于以a[i]之前的一个数j（该数的值小于a[i]来保证递增并
且max是指我们要取使dp[j]最大的这个数）结尾的序列的最长递增子序列长度算上a[i]本身。
     代码实现时，我们需要遍历在i之前的所有位置j(从0到i-1)，找出满足条件a[j]<a[i]的dp[j]，求出max(dp[j])+1
即为dp[i]的值。
*/
import java.util.*;
public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextLine()){
            int n = Integer.parseInt(sc.nextLine());
            String str = sc.nextLine();
            System.out.println(removeNo(str,n));
        }
    }

    public static int removeNo(String str,int n){
        String[] stra = str.split(" ");
        int[] height = new int[n];//分别为正序和逆序的整型数组
        int[] heightopp = new int[n];
        for(int i=0;i<n;i++){
            height[i] = Integer.parseInt(stra[i]);
        }
        for(int i=0;i<n;i++){
            heightopp[i] = height[n-i-1];
        }
         int[] dp = Maxsub(height,n);//递增计数
         int[] dpopp = Maxsub(heightopp,n);//递减计数（逆序）
         int[] sum = new int[n];
         for(int i=0;i<n;i++){
             sum[i] = dp[i]+dpopp[n-i-1];//相加时要将递减计数倒过来
         }
        int max = 0;//求递增计数与递减计数之和的最大值
        for(int i=0;i<n;i++){
            max = sum[i]>max?sum[i]:max;
        }
        return n-(max-1);//返回出列人数
    }

    public static int[] Maxsub(int[] stra,int n){//按公式dp[i]={max(dp[j])+1,j<i且a[j]<a[i]}求dp[i]
        int[] dp = new int[n];
        for (int i=0;i<n;i++){
            dp[i] = 1;
            for (int j=0;j<i;j++) {
                 if (stra[j]<stra[i]) {
                   dp[i] = Math.max(dp[i], dp[j]+1);
                }
            }
        }
        return dp;
    }
}
```

####  字符串排序

> 编写一个程序，将输入字符串中的字符按如下规则排序。
>
> 规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。
>
> 如，输入： Type 输出： epTy
>
> 规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。
>
> 如，输入： BabA 输出： aABb
>
> 规则 3 ：非英文字母的其它字符保持原来的位置。
>
> 如，输入： By?e 输出： Be?y
>
> 注意有多组测试数据，即输入有多行，每一行单独处理（换行符隔开的表示不同行）

```java
import java.util.*;

public class Main{
    
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            String str = in.nextLine();
            char[] chr = str.toCharArray();
            List<Character> list = new LinkedList();
            for(Character ch : chr){
                if(Character.isLetter(ch))
                    list.add(ch);
            }
            
            Collections.sort(list, new Comparator<Character>(){
                public int compare(Character c1, Character c2){
                    return Character.toLowerCase(c1) - Character.toLowerCase(c2);
                }
            });
            int cnt = 0;
            for(int i = 0; i < chr.length; i++){                
                if(Character.isLetter(chr[i])){
                    chr[i] = list.get(cnt);
                    cnt++;
                }
            }

            System.out.println(chr);
        }
    }
}
```

####  [解的巧妙]查找兄弟单词

> 定义一个单词的“兄弟单词”为：交换该单词字母顺序，而不添加、删除、修改原有的字母就能生成的单词。
>
> 兄弟单词要求和原来的单词不同。例如：ab和ba是兄弟单词。ab和ab则不是兄弟单词。
>
> 现在给定你n个单词，另外再给你一个单词str，让你寻找str的兄弟单词里，字典序第k大的那个单词是什么？
>
> 注意：字典中可能有重复单词。本题含有多组输入数据。
>
> ```
> 先输入单词的个数n，再输入n个单词。
> 再输入一个单词，为待查找的单词x
> 最后输入数字k
> 
> 输出查找到x的兄弟单词的个数m
> 然后输出查找到的按照字典顺序排序后的第k个兄弟单词，没有符合第k个的话则不用输出。
> 
> 3 abc bca cab abc 1
> 2
> bca
> ```

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

/*
	a-z：97-122
	A-Z：65-90
	0-9：48-57
 */
public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader scanner = new BufferedReader(new InputStreamReader(System.in));
        String str;
        while ((str = scanner.readLine()) != null && !str.equals("")) {
            String[] s = str.split(" ");
            int count = Integer.parseInt(s[0]);
            int show = Integer.parseInt(s[s.length-1]);
            String target = s[s.length-2];
            int res=0;
            List<String> list = new LinkedList<>();
            for (int i = 1; i < count+1; i++) {
                if (isBrotherWord(target, s[i])){
                    res++;
                        list.add(s[i]);
                }
            }

            System.out.println(res);
            Collections.sort(list);
            if (show<=list.size()){
                System.out.println(list.get(show-1));
            }
        }
    }

    public static boolean isBrotherWord(String target, String word){
        if (target.equals(word)) return false;
        if (target.length()!=word.length()){
            return false;
        }else {
            int[] t = new int[26];
            for (int i = 0; i < target.length(); i++) {
                t[target.charAt(i)-97] ++;
                t[word.charAt(i)-97] --;
            }
            for (int i = 0; i < 26; i++) {
                if (t[i]!=0){
                    return false;
                }
            }
        }
        return true;
    }

}
```

####  [没解开]素数伴侣

> 题目描述
> 若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。
>
> 输入:有一个正偶数N（N≤100），表示待挑选的自然数的个数。后面给出具体的数字，范围为[2,30000]。
>
> 输出:输出一个整数K，表示你求得的“最佳方案”组成“素数伴侣”的对数。
>
> ```java
> 输入说明
> 1 输入一个正偶数n
> 2 输入n个整数
> 注意：数据可能有多组
> 
> 求得的“最佳方案”组成“素数伴侣”的对数。
> ```

```java
//质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）

//合数 是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数

//偶数 任何可以被 2 整除的整数就是偶数。

//奇数 任何不能被 2 整除的整数就是奇数。
```

#### 最小公倍数

> 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。

```java
import java.util.Scanner;

public class Main{
    
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int val1 = scanner.nextInt();
        int val2 = scanner.nextInt();
        // 1.  找到最小公约数
        int leastCommonMultiple = findLeastCommonMultiple(val1, val2);
        System.out.println((val2 * val1) / leastCommonMultiple);
    }

    public static int findLeastCommonMultiple(int val1, int val2) {
        int diff = val1 - val2;
        if (diff == 0) {
            return val2;
        } else if (diff < 0) {
            return findLeastCommonMultiple(-1 * diff, val1);
        } else {
            return findLeastCommonMultiple(diff, val2);
        }
    }
}
```

#### 解决立方根

> 计算一个数字的立方根，不使用库函数。保留一位小数。

```java
命f(x) = x^3 - a，求解f(x) = x^3 - a = 0。
利用泰勒公式展开，即f(x)在xo处的函数值为：
f(x) = f(xo) +f'(xo)(x-xo) = xo^3-a+3xo^2(x-x0) = 0，
解之得：x = xo - (xo^3 - a) / (3xo^2)。
```

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Double input = scanner.nextDouble();
        
        Double initial = 0.0;
        while(Math.abs(Math.pow(initial, 3) - input) > 0.0001) {
            Double g = Math.pow(initial, 3) - input;
            Double g2 = Math.pow(initial, 2) * 3;
            initial = initial - 0.001 * g / (g2 + 0.01);
        }
        System.out.println(String.format("%.1f", initial));
    }
}
```

#### 字符逆序

> 将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。
>
> ```
> I am a student
> tneduts a ma I
> ```

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new  Scanner(System.in);
        String line = scanner.nextLine();
        String res = "";
        for(int i=line.length();i>0;i--) {
            res = res + line.substring(i-1,i);
        }
        System.out.println(res);
    }
}
```

#### 学习英语

> Jessi初学英语，为了快速读出一串数字，编写程序将数字转换成英文：
>
> 如22：twenty two，123：one hundred and twenty three。
>
> 说明：
>
> 数字为正整数，长度不超过九位，不考虑小数，转化结果为英文小写；
>
> 输出格式为twenty two；
>
> 非法数据请返回“error”；
>
> 关键字提示：and，billion，million，thousand，hundred。
>
> 本题含有多组输入数据。

```java
import java.util.*;
public class Main {

	public static String[] num1 = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };
	public static String[] num2 = { "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen","seventeen", "eighteen", "nineteen" };
	public static String[] num3 = { "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty","ninety" };

	public static String parse(long num){
		if(num < 0){
			return "error";
		}
		StringBuilder sb = new StringBuilder();
		long billion = num / 1000000000;    //十亿部分
		if(billion != 0){
			sb.append(trans(billion) + " billion ");
		}
		num  %= 1000000000;
		
		long million = num / 1000000;    //百万部分
		if(million != 0){
			sb.append(trans(million) + " million ");
		}
		num  %= 1000000;
		
		long thousand = num / 1000;    //千部分
		if(thousand != 0){
			sb.append(trans(thousand) + " thousand ");
		}
		num  %= 1000;
	
		if(num != 0){
			sb.append(trans(num));
		}
		return sb.toString().trim();   //最后去除字符串后面的空格
	}

	public static String trans(long num){
		StringBuilder sb = new StringBuilder();
		long h  = num / 100;  //百位处理
		if(h != 0){
			sb.append(num1[(int) h] + " hundred");
		}
		num %= 100;
		
		long k = num / 10;    //十位处理
		if(k != 0){
			if(h != 0){    //若有百位，则加上“and”
				sb.append(" and ");
			}
			if(k == 1){   //如果十位为1，那么十位与个位一起翻译，如：113
				sb.append(num2[(int)(num % 10)]);
			}else{  //否则，十位和个位分别单独翻译，如：123
				sb.append(num3[(int) (k - 2)] + " ");
				if(num % 10 != 0){
					sb.append(num1[(int) (num % 10)]);
				}
			}
		}else if (num % 10 != 0) {  //如果没有十位的部分，则直接翻译个位部分，比如：102
			if(h != 0){
				sb.append(" and ");
			}
			sb.append(num1[(int) (num % 10 )]);
		}
		return sb.toString().trim();
	}

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while (in.hasNext()) {
			long num = in.nextLong();
			System.out.println(parse(num));
		}
		in.close();
	}
}
```

#### 按字节截取字符串

> ## 题目描述
>
> 输入一个字符串和一个整数k，截取字符串的前k个字符并输出
>
> 本题输入含有多组数据
>
> ## 输入描述:
>
> ```
> 第一行输入待截取的字符串
> 第二行输入一个正整数k，代表截取的长度
> ```
>
> ## 输出描述:
>
> ```
> 截取后的字符串
> ```

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception{
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String str = sc.next();
            String[] strs = new String[str.length()];
            for (int i = 0; i < strs.length; i++) {
                strs[i] = String.valueOf(str.charAt(i));
            }
            int byteNum = sc.nextInt();
            StringBuilder res = new StringBuilder();
            for (int i = 0; i < strs.length; i++) {              
                int chLen = strs[i].getBytes("GBK").length;
                if (byteNum >= chLen){
                    byteNum -= chLen;
                    res.append(strs[i]);
                }else {
                    break;
                }
            }
            System.out.println(res.toString());
        }
    }
}
```

####  多线程

> 4个线程分别向一个数组中输出 `ABCDABCDABCD`

```java
import java.util.*;
//临界资源
class CharBuffer{
    private StringBuffer value = new StringBuffer();//共享变量
    private int num = 0;                            //添加次数
    private int order = 0;                          //信号量，约定发送线程的次序

    public String getVal(){
        return value.toString();
    }
    public CharBuffer(int num){
        this.num = num;
    }
    //临界区
    public synchronized void put(char c,int order){
        if(this.order != order){
            try {
                this.wait();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            return;
        }
        value.append(c);                  //将字母添加到共享资源
        this.order = (this.order + 1) % 4;
        if(this.order == 0)
            num --;
        this.notifyAll();
    }

    public int getNum(){
        return num;
    }

}
//发送线程
class SendThread extends Thread{
    private CharBuffer cb;
    private int order = 0;         //信号量，约定发送线程次序
    private char c;
    public SendThread(char c,int order,CharBuffer cb){
        this.c = c;
        this.order = order;
        this.cb = cb;
    }

    public void run(){
        while(cb.getNum() != 0){
            cb.put(c,order);
        }
    }
}
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            CharBuffer cb = new CharBuffer(n);
            //创建线程
            SendThread st1 = new SendThread('A',0,cb);
            st1.start();
            SendThread st2 = new SendThread('B',1,cb);
            st2.start();
            SendThread st3 = new SendThread('C',2,cb);
            st3.start();
            SendThread st4 = new SendThread('D',3,cb);
            st4.start();
            try {
                //等待4个线程运行结束
                st1.join();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            System.out.println(cb.getVal());
        }
    }
}
```

####  四则运算

> 输入一个表达式（用字符串表示），求这个表达式的值。
>
> 保证字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。且表达式一定合法。
>
> ## 输入
>
> 复制
>
> ```
> 3+2*{1+2*[-4/(8-6)+7]}
> ```
>
> ## 输出
>
> 复制
>
> ```
> 25
> ```

```java
package com.it.leetcode.huaweiM;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.util.*;

public class Main{
    // 用于存放一个正括号的集合, 用于简化代码
    static Set<Character> brace = new HashSet<>();
    public static void main(String ... args){
        Scanner sc = new Scanner(System.in);
        // 初始化正括号集合
        brace.add('{');
        brace.add('(');
        brace.add('[');
        while(sc.hasNextLine()){
            // 对字符串做初始化处理，原则有二:
            // 1、处理负数，这里在-前面的位置加入一个0，如-4变为0-4，
            // 细节：注意-开头的地方前面一定不能是数字或者反括号，如9-0,(3-4)-5，这里地方是不能加0的
            // 它的后面可以是数字或者正括号，如-9=>0-9, -(3*3)=>0-(3*3)
            // 2、处理字符串，在最后的位置加#, 主要是为了防止最后一个整数无法处理的问题
            String exp = sc.nextLine().replaceAll("(?<![0-9)}\\]])(?=-[0-9({\\[])", "0") + "#";
            System.out.println(calculate(exp));
        }
    }
    private static int calculate(String exp){
        // 初始化栈
        Stack<Integer> opStack = new Stack<>(); // 运算数据
        Stack<Character> otStack = new Stack<>(); // 运算符号

        // 整数记录器
        String num = "";
        for(int i = 0; i < exp.length(); i++){
            // 抽取字符
            char c = exp.charAt(i);
            // 如果字符是数字，则加这个数字累加到num后面
            if(Character.isDigit(c)){
                num += c;
            }
            // 如果不是数字
            else{
                // 如果有字符串被记录，则操作数入栈，并清空
                if(!num.isEmpty()){
                    int n = Integer.parseInt(num);
                    num = "";
                    opStack.push(n);
                }
                // 如果遇上了终结符则退出
                if(c == '#')
                    break;
                    // 如果遇上了+-
                else if(c == '+' || c == '-'){
                    // 空栈或者操作符栈顶遇到正括号，则入栈，otStack.peek 需要时 + - 或者 [ ( { 中的符号
                    if(otStack.isEmpty() || brace.contains(otStack.peek())){
                        otStack.push(c);
                    } else {
                        // 否则一直做弹栈计算，直到空或者遇到正括号为止，最后入栈，一待 otStack.peek 出现 } ] ) 那么就开始计算结果
                        while(!otStack.isEmpty() && !brace.contains(otStack.peek()))
                            popAndCal(opStack, otStack);
                        otStack.push(c);
                    }
                }
                // 如果遇上*/
                else if(c == '*' || c == '/'){
                    // 空栈或者遇到操作符栈顶是括号，或者遇到优先级低的运算符，则入栈
                    if(otStack.isEmpty()
                            || brace.contains(otStack.peek())
                            || otStack.peek() == '+' || otStack.peek() == '-'){
                        otStack.push(c);
                    }else{
                        // 否则遇到*或/则一直做弹栈计算，直到栈顶是优先级比自己低的符号，最后入栈
                        while(!otStack.isEmpty()
                                && otStack.peek() != '+' && otStack.peek() != '-'
                                && !brace.contains(otStack.peek()))
                            popAndCal(opStack, otStack);
                        otStack.push(c);
                    }
                } else {
                    // 不是 +-*/符号，也不是 num， 那么久只能是 括号操作符了，如果是正括号就压栈
                    if(brace.contains(c))
                        otStack.push(c);
                    else{
                        // 反括号就一直做弹栈计算，直到遇到正括号为止
                        char r = getBrace(c);
                        while(otStack.peek() != r){
                            popAndCal(opStack, otStack);
                        }
                        // 最后弹出正括号
                        otStack.pop();
                    }
                }
            }
        }
        // 将剩下的计算完，直到运算符栈为空
        while(!otStack.isEmpty())
            popAndCal(opStack, otStack);
        // 返回结果
        return opStack.pop();
    }
    private static void popAndCal(Stack<Integer> opStack, Stack<Character> otStack){
        int op2 = opStack.pop();
        int op1 = opStack.pop();
        char ot = otStack.pop();
        int res = 0;
        switch(ot){
            case '+':
                res = op1 + op2;
                break;
            case '-':
                res = op1 - op2;
                break;
            case '*':
                res = op1 * op2;
                break;
            case '/':
                res = op1 / op2;
                break;
        }
        opStack.push(res);
    }
    private static char getBrace(char brace){
        switch(brace){
            case ')':
                return '(';
            case ']':
                return '[';
            case '}':
                return '{';
        }
        return '#';
    }
}
```

#### 线性插值

> 信号测量的结果包括测量编号和测量值。存在信号测量结果丢弃及测量结果重复的情况。
>
> 1.测量编号不连续的情况，认为是测量结果丢弃。对应测量结果丢弃的情况，需要进行插值操作以更准确的评估信号。
>
> 采用简化的一阶插值方法,由丢失的测量结果两头的测量值算出两者中间的丢失值。
>
> 假设第M个测量结果的测量值为A，第N个测量结果的测量值为B。则需要进行(N-M-1)个测量结果的插值处理。进行一阶线性插值估计的第N+i个测量结果的测量值为A+( (B-A)/(N-M) )*i (注：N的编号比M大。)
>
> 例如：只有测量编号为4的测量结果和测量编号为7的测量结果，测量值分别为4和10
>
> 则需要补充测量编号为5和6的测量结果。
>
> 其中测量编号为5的测量值=4 + ((10-4)/(7-4))*1 = 6
>
> 其中测量编号为6的测量值=4 + ((10-4)/(7-4))*2 = 8
>
> 2.测量编号相同，则认为测量结果重复，需要对丢弃后来出现的测量结果。

```java

```



