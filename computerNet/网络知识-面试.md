[B 站来源](https://www.bilibili.com/video/BV1T5411p78c)

主要内容：

* 从一个HTTP 请求来看网络分层原理
* HTTP
* HTTP 请求的完整过程
* TCP 协议
* HTTPS 协议

---

#### 从一个HTTP 请求来看网络分层原理

![a](./picture/class_1.png)

数据从一个 `host` 传输到另外一个 `host` 会经过很多的网络设备，不管是哪个网络设备多会出现**数据包丢失**的问题，当发生丢失的情况，那么就需要重新传输数据，那么重新传输数据则也有可能发生**数据重复**的问题(数据包每没有丢失，只是延迟了，然后就被认为是丢失了)，由于设备出现故障或者数据传输过程被认为篡改，那么还需要有**数据完整性校验**，同时，如果是在公网上传输，还需要经过光电**信号的转换**，传输的过程中，还会涉及到**信号衰减**.

**所以网络在整个传输的过程中是一个非常复杂的过程。**

---

为了简化这个复杂的过程，于是对网络进行了分层

每一层只和紧挨着的上层或者下层进行交互，往网络分层，这样可以修改，甚至替换某一层的软件，只要层与层之家的接口保持不变.

![a](./picture/osi_model.png)

应用层是各种各样的软件。

应用层以下的是计算机的内核部分，是计算机的功能。

对于开发人员，可以只认识其2层，**应用层**和**内核层**

---

![a](./picture/http1.png)

通过域名访问公网

1. 浏览器解析域名
   1. 查看浏览器中是否有缓存，有则返回，否则继续往下
   2. 查看本地机器的 hosts 配置文件中是否有域名对应的IP 地址，有则返回，否则继续往下
   3. 去DNS 服务器你请求IP
      1. 去本地机器上配置的DNS IP，去这个IP 地址去拿域名对应的IP
      2. 如果本队DNS 中获取不到，那么去这个DNS 的根DNS 服务器去查，直到查到后返回
2. 网络层 将IP加到请求报文
3. 数据链路层，二层寻址，将自己的MAC 地址加到请求报文
4. 物理层
5. 路由器，三层设备

---

#### HTTP

超文本传输协议，名字中有`传输` 字样，其实他本身并不具有传输的能力(通过TCP 协议传输)，它是一种**无状态(本身不存储用户信息)**的，以**应答的方式运行的协议**。使用**可扩展性的语义(头部字段可以用户自动配置)和自描述消息格式**，和基于超文本信息系统灵活的互动

##### HTTP 报文

三大部分组成

* 起始行：描述请求或响应的基本信息

![a](./picture/http12.png)

* 头部字段集合：使用 key-value 形式更详细的说明报文
* 消息正文：实际传输的数据，可以是文本，图片，视频等

![a](./picture/http2.png)

头字段，可以是任意自定义的头部，给HTTP 带来了无限的扩展可能。

* 头字段不区分大小写，不可以出现空格，可以使用连字符'-'，但是不能使用下划线

* 字段顺序没有语义的

* 原则上不能出现重复

  > 常用字段
  >
  > 请求字段：`Host`,`Refer`
  >
  > 响应字段：响应头中的字段 `Server`
  >
  > 通用字段,请求头和响应头中都可以出现：`Content-type`/`Connection`

##### HTTP 请求过程

当用户浏览器地址栏中输入地址回车之后，发生什么事情呢？

* 首先干活的是浏览器应用程序，他要解析出`URL` 的域名

* 根据域名获取对应的 `IP` 地址，首先从浏览器的缓存中查看，如下可以查看浏览器中对应的`IP` 解析

  `chrome://net-internals/#events`

  如果没有则从本地域名及文件 `hosts` 中查查看，还没有则去本地`DNS/`根`DNS server` 中去获取(根`DNSServer` 获取不到`IP`那么就去父`dns`  服务器获取)，知道获得`IP`

* 浏览器发起` http` 请求报文，发送报文

  * 发送就需要使用到`TCP` 部分，`TCP` 发送

* 服务器收到请求报文之后，解析报文，生成响应，发送响应数据

* 浏览器收到效应，开始渲染页面

![a](./picture/http3.png)

---

#### TCP

`Transmission Control Protocol`, 面向连接的，可靠的、基于字节流的传输层通信协议

特点：

* 基于连接的，数据传输之前需要建立连接
* 全双工的，双向传输，客户端，服务器可以相互读写数据
* 字节流，不限制数据大小，打包成报文段(数据切分，排序)，保证有序接收，重复报文自动丢失
* 流量缓存，解决双方传输能力不匹配
* 可靠的传输服务，保证到达，丢包时候通过重发机制实现可靠性
* 拥塞控制：防止网络出现恶性拥塞，如网络比较卡，那么发送的数据会变小，且发送速率会变小。

##### TCP 连接管理

1. TCP 连接四元组：源地址:源端口， 目标地址:目标端口
2. 确立连接: TCP 三次握手
   1. 同步通信双方初始序列化
   2. 协商TCP 通信参数

**如何握手**： 前提是先建立连接

先看看TCP 的报文

![a](./picture/http4.png)

`Options 和 Data` 是不必填项

中间大写是`报文标志`，表示当前是一个什么类型的报文，如 `SYN=1` 是建立连接的同步序列号

`ACK=1` 是响应报文(确认响应以及到达)。

`FIN` 关闭连接的报文

`Receive window` 当前服务器可以接受数据大小的一个值。

`URG=1`  是一个紧急的报文，服务器优先去处理，指向 `Urgent data pointer ` 内存

`Data` 传输的内容，如发送`HTTP` 报文的时候，里面存放的就是`http`  的报文。

![a](./picture/http5.png)

1. 服务器首先会进入 `LISTEN` 的状态，监听一个端口，如 `80`
2. 客户端发送一个请求，创建一个数据结构，用来存储使用的源端口(一般随机生成)，目的端口，目的IP，序号、应答号、对方窗口大小、自己窗口大小、缓冲区等，发送 `SYN` 的请求报文，然后客户端进入 `syn-send`  状态。
3. 服务端受到之后，也是立马创建和连接相关的自己的一个数据结构，并且给客户端回一个 `ack`  确认的报文，表示客户端的报文以及被服务端接收到了，同时服务端也会给你客户端发送 `SYN` 报文，同时这个过程都带着 `seq` 序列号，它的作用是知道客户端服务端识别是谁发送/应答的请求。相互唯一确认对方，服务端的状态发生变化
4. 当客户端接收到`SYN`消息之后，然后客户端的状态也发生变化，状态发送变化`ESTABLISHED`
5. 然后告诉服务端 `ACK`, 接收到了报文。
6. 服务器端接收到客户端的`ACK`,却客户端以及接收到服务端发送的连接请求
7. 这样双放都确认并建立了安全的相互信任的连接

以上客户端确认了服务端，服务端确认了客户端，完成三次握手

---

##### 四次挥手： 关闭连接

客户端和服务端都可以关闭

1. 客户端发送 `FIN` 报文，告诉服务端，我这边不会再给你发送数据了。

2. 服务端会给客户端发送 `ack`  表示收到了客户端的报文

  这个时候是客户端后面不在向服务端发送数据，这个时候服务端可能还在对之前客户端发的请求进行一些  处理，还可能会给客户端发送请求。

3. 服务器的收尾工作做完了，之后也不会再给客户端发送响应了，于是给客户端发送 `FIN ` 的报文，也告诉客户端，我后面也不在给你发送响应了

4. 客户端收到之后，回复 `ACK` 给服务端，服务端断开连接

在客户端关闭的之前，会有2个MSL(请求在客户端和服务器的一个来回时间) 等待时间，之所以要这么2个等待时间，是因为，如果不等待，那么会发生

* 加入直接关闭了，而关闭前的发送给服务端的`ACK` 丢失了，没有收到，那么服务器会不间断的发送`FIN`但是客户端这个时候已经是关联了的，再也无法给服务器发送`ack`了，就会导致服务器一直无法关闭。加了这个等待时间，就是等待服务器能够安全收到了客户端的`ack`
* 还有就是进一步的，在上一个问题的基础上，假如说客户端已经关闭了，但是服务端没有收到`ack` ，会有这样的事情发生，那就是客户端的端口可能会分配给其他的连接使用，而服务器还在发送`FIN`，这个时候就会对新建立的连接产生影响。

![a](./picture/http13.png)



双方连接均断开。

---

#### 字节流协议

TCP 把应用交付的数据仅仅看成是一连串的无结构的字节流，TCP 并不知道字节流的含义，TCP 并不关心应用程序一次次将多大的报文发送到TCP 的缓存中，而是根据对方给出的窗口值和当前网络拥堵程度来决定一个报文段应该包含多少个字节

MSS： Max Segmeng Size： 默认526byte 实际数据

如何保证传输过程中数据拆分后，在接收之后的顺序呢？通过  seq ，它会标志数据的顺序。

#### 数据是如何可靠性传输的呢

1. 停止等待协议

![a](./picture/http14.png)

发一个确认一个，然后在发一个确认一个，串行的方式，效率低。

2. 重传机制

   ack 报文丢失

   ![a](./picture/http15.png)

   请求报文丢失

   ![a](./picture/http16.png)

   重传机制，容易导致数据重复发送，而且一个报文就发送一个 `ack` 也是有点浪费资源的。如果可以发送很多个报文，而只发送一个`ack` 那不更好。

3. 滑动窗口发送

   发送一个窗口数据，值确认窗口最后一个字节流，最后一个个收到了，那么才发送`ack`

   ![a](./picture/http17.png)

   接收方知道收到5，那么发送方这个窗口的数据才算全部发送结束，那么接受放才返回 `ack`

---

#### HTTP 协议

`HTTP`  是数据在整个网络上 `裸奔`的，数据均是明文的。任何人都会截获，修改或者伪造报文，具有**不可靠性**

`HTTPS` 是在 `HTTP` 和`TCP` 层传输中间上加了一层安全层，也就是在数据传输之前进行加密，接收到的事实在解密，在传输的过程中是密文。

![a](./picture/http6.png)

**SSL/TSL**

SSL： Secure Socket Layer，后来改为了 TLS: Transport Layer Secure

**摘要算法**

> 将任意数据加密为定长的密文，如有 sha1, sha2, sha1 256, md5
>
> 如果数据有任意的一个变动，其加密后的值都是完全不一样的。

**对称加密**

> 编码、解码使用相同的秘钥，如AES/RC4/ChaCha20

**非对称加密**

> 2个密匙，一个公钥，一个私钥，公钥是可以公开的，私钥是保密的，非对称加密是可以解决 **秘钥交换** 的问题，网站密码保管私钥，公钥任意分发，登录网站，**只需要使用公钥加密就可以，密文只能有私钥持有者才能解密。私钥加密可以用公钥解密。公钥加密私钥也可以解密，但是公钥和公钥或者私钥和私钥 是不能自己加解密的。**

单独使用对称加密，那么无法完成加密密匙的传输

而单独使用非对称加密，那么服务器返回给客户端的数据几乎是 **裸奔的**，因为公钥 是被公开的了，服务器发出来的 私钥 加密的数据 ，是可以被公开的公钥解密的。

在传输的时候，非对称加密算法，完成加密算法的一个传输。二者取长补短

1. 在建立完成TCP 连接 之后
2. HTTP   S 层进行交换密匙，服务器端会返回公钥
3. 客户端使用公钥将客户端发起的 `对称加密秘钥` 使用公钥加密，这个时候 传输的过程中，是 无法截获这个对称加密秘钥的，因为公钥是无法解开公钥加密的信息的，只有私钥可以。
4. 服务端接收到 之后，使用 私钥将 数据解密，拿到客户端的对称加密秘钥，使用该秘钥加密数据和客户端进行数据交换，这个传输过程中，信息是无法被截获的(都是对称加密加密的) 。后面的数据 的传输都是通过对称加密算法 加密传输 的。

对此加密算法比非对称加密算法效率更高。

这样后面服务器和客户端就能正常加密传输了。

这里会有一个问题，

![a](./picture/http8.png)

在最初的建立TCP 连接的是，如果就被黑客给黑了，在客户端不知道的情况下，黑客伪造了公钥私钥，那么后面客户端发送的数据就被解密了。基于此又发明了 **证书**

在服务器给客户端发送公钥的时候不单纯发送一个公钥，而是**公钥数字证书**，证书中还会加一些签名信息，这些签名均是权威机构发布的，用来证明这个公钥的正确性，不是黑客所为。

![a](./picture/http9.png)

**浏览器验证证书**

证书里面会包含加密证书的哈希算法，将证书解密，然后拿着解密的明文信息，得到摘要，拿着CA

浏览器就能查看到证书的信息

![a](./picture/http11.png)

<img src="./picture/http10.png" alt="a" style="zoom:50%;" />

---

当前请求的IP 和路由表中的掩码进行运算得到目的地的网关(下一条)，然后通过网关将其发送出去。

---

#### 一些面试题汇总

### 1. TCP三次握手和四次挥手

1.1 TCP三次握手和四次挥手的过程

1.2 为什么TCP建立连接需要三次握手,断开连接需要四次挥手

1.3 TCP四次挥手为什么有Time-Wait过程

1.4 TCP如果没有完成第四次挥手会发生什么: 

1.5 TCP第三次握手可以传输数据吗



### 4. 常见的HTTP状态码

### 5. HTTP报文

5.1 HTTP请求报文和响应报文的组成
5.2 HTTP请求报文包含哪些方法, GET和POST的区别

### 6. HTTP和HTTPS的区别

### 7. HTTP1.0和1.1和2.0的区别

>  Http1.x
>
> - **缺陷**：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞
>
> #### http1.0
>
> - **缺陷**：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（T**CP连接的新建成本很高，因为需要客户端和服务器三次握手**），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；
> - **解决方案**：
>   - 添加头信息——非标准的Connection字段`Connection: keep-alive`
>
> 1. **持久连接**
>    - 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`(对于同一个域名，大多数浏览器允许同时建立6个持久连接)
> 2. **管道机制(多路复用)**
>    - 即在同一个TCP连接里面，客户端可以同时发送多个请求。
> 3. **分块传输编码**
>    - 即服务端没产生一块数据，就发送一块，采用”流模式”而取代”缓存模式”。
> 4. **新增请求方式**
>    - PUT:请求服务器存储一个资源;
>    - DELETE：请求服务器删除标识的资源；
>    - OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；
>    - TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断；
>    - CONNECT：保留将来使用
>
> - **缺点：**
>   - 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是**按次序进行**的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”
>   - **避免方式：**一是减少请求数，二是同时多开持久连接
>
> #### HTTP/2.0
>
> > 1. 采用二进制格式而非文本格式；
> > 2. 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行；
> > 3. 使用报头压缩，降低开销
> > 4. 服务器推送

### 8. HTTPS密钥交换过程

### 9. HTTP的缓存机制

### 10. 输入URL跳转网页的过程

> 发送http 的过程

### 11. 计算机网络四层协议,五层协议,七层协议

>  OSI 模型以及N层负载是怎么回事笔记

### 12. 什么是cookie和session,区别是什么, 禁用cookie怎么办

> 都是用来保持 `http` 的状态
>
> Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。 而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。

### 13. 页面加载不出来的原因