```shell
free | grep Mem | tr -s " "| cut -d " " -f 7
 
[root@slave2 ~]# echo "aaa bbb" | tr -s "a"
a bbb
[root@slave2 ~]# echo "a---b---c" | tr -s "-"
a-b-c
[root@slave2 ~]# echo "a-b-c" | cut -d"-" -f1
a
[root@slave2 ~]# echo "a-b-c" | cut -d"-" -f2
b
[root@slave2 ~]# echo "a-b-c" | cut -d"-" -f3
c
[root@slave2 ~]# echo "a-b-c" | cut -d"-" -f4
```

都使用了tr和cut命令，tr -s后面使用引号引用了一个空格，作用是将管道传送的数据中连续的多个空格合并为一个空格。如果-s选项后面使用引号引用其他的字符，则效果也一样，可以把多个连续的特定字符合并为一个字符。

使用cut命令，可以帮助我们获取数据的特定列（使用-f选项指定需要获取的列数），并且可以通过-d选项设置以什么字符为列的分隔符。具体参考下面的案例

---

当需要读取变量值时，需要在变量名前添加一个美元符号“$”；而当变量名与其他非变量名的字符混在一起时，需要使用{}分隔

---

```shell
-- sys_var.sh

#!/bin/bash
echo "当前账户是:${USER},当前账户的UID:${UID}"
echo "当前账户的根目录是: $HOME"
echo "当前脚本的进程号是:$$"
echo "当前脚本的名称是:$0"
echo "当前脚本的第一个参数是：$1"
echo "当前脚本的第二个参数是：$2"
echo "当前脚本的所有参数是: $*"


[root@slave2 ~]# bash sys_var.sh 1 2 3
当前账户是:root,当前账户的UID:0
当前账户的根目录是: /root
当前脚本的进程号是:14130
当前脚本的名称是:sys_var.sh
当前脚本的第一个参数是：1
当前脚本的第二个参数是：2
当前脚本的所有参数是: 1 2 3
```

---

#### grep

grep命令可以查找关键词并打印匹配的行。

grep [选项] 匹配模式 [文件]

* -i 忽略字母大小写
* -w 匹配单词
* -q 静默匹配，不讲结果显示在屏幕上
* -v 取返匹配

```shell
#!/bin/bash
th ad th ads dsd sf th
dsad fd af d f tf
daf d fdatgt  htethe
fgtdsfrgt gtef g
fgdgte  num

[root@slave2 ~]# grep th sys_var.sh # 过滤包含 th 的行
th ad th ads dsd sf th
daf d fdatgt  htethe
[root@slave2 ~]# grep -i th sys_var.sh  # 过滤包含 th 的行，不区分大小写
th ad th ads dsd sf th
daf d fdatgt  htethe
[root@slave2 ~]# grep -i the sys_var.sh # 过滤包含 the 的行
daf d fdatgt  htethe
[root@slave2 ~]# grep -v the sys_var.sh
#!/bin/bash
th ad th ads dsd sf th
dsad fd af d f tf
fgtdsfrgt gtef g
fgdgte  num
```

#### $？查看上一条命令的退出码，0代表正确（true），非0代表错误（false）

```shell
[root@slave2 ~]# test a == b
[root@slave2 ~]# echo $?
1
[root@slave2 ~]# echo $a
11
[root@slave2 ~]# echo $b
12

[root@slave2 ~]# [ a == b ];echo $?
1

```

多数情况下[]和[[]]是可以通用的，两者的主要差异是：test或[]是符合POSIX标准的测试语句，兼容性更强，几乎可以运行在所有Shell解释器中，相比较而言[[]]仅可运行在特定的几个Shell解释器中（如Bash、Zsh等）。事实上，目前支持使用[[]]进行条件测试的解释器已经足够多了

#### 比较

* -eq
* -ne
* -gt
* -ge
* -lt
* -le

```shell
[root@slave2 ~]# [ $a -ne $b ];echo $?
0
[root@slave2 ~]# [ $a -le $b ];echo $?
0
[root@slave2 ~]# [ $a -eq $b ];echo $?
1
```

#### 案例-时间格式化

```shell
[root@slave2 ~]# local_time=$(date +"%Y-%m-%d %H:%M:%S")
[root@slave2 ~]# echo $local_time
2022-06-07 23:29:01
```

#### 案例-截取内容

```shell
[root@slave2 ~]# ip=$(ifconfig lo | grep netmask | tr -s " " | cut -d" " -f1);echo $ip

[root@slave2 ~]# ip=$(ifconfig lo | grep netmask | tr -s " " | cut -d" " -f2);echo $ip
inet
[root@slave2 ~]# ip=$(ifconfig lo | grep netmask | tr -s " " | cut -d" " -f3);echo $ip
127.0.0.1
[root@slave2 ~]# ip=$(ifconfig lo | grep netmask | tr -s " " | cut -d" " -f4);echo $ip
netmask
[root@slave2 ~]# ip=$(ifconfig lo | grep netmask | tr -s " " | cut -d" " -f5);echo $ip
255.0.0.0
```

#### 案例-查看可用磁盘大小

```shell
[root@slave2 ~]# free_disk=$(cat /proc/meminfo | grep Avai | tr -s " " | cut -d" " -f2);echo $free_disk
2668296
```

#### 案例-统计个数

```shell
[root@slave2 ~]# who | wc -l
1
```

#### if

在Shell脚本中if语句有三种格式，分别是单分支if语句、双分支if语句和多分支if语句。

下面是单分支if语句的语法格式

```shell
if 条件测试
then
   命令序列
fi
```

if和then可以写在同一行。同一行中如果需要编写多条命令，中间需要使用分号分隔命令

#### if 条件判断运算符号

```shell
-----------------e filename 如果 filename存在，则为真
-d filename 如果 filename为目录，则为真 
-f filename 如果 filename为常规文件，则为真
-L filename 如果 filename为符号链接，则为真
-r filename 如果 filename可读，则为真 
-w filename 如果 filename可写，则为真 
-x filename 如果 filename可执行，则为真
-s filename 如果文件长度不为0，则为真
-h filename 如果文件是软链接，则为真
filename1 -nt filename2 如果 filename1比 filename2新，则为真。
filename1 -ot filename2 如果 filename1比 filename2旧，则为真。

If  [ $a = $b ]                 如果string1等于string2，则为真
                                字符串允许使用赋值号做等号
if  [ $string1 !=  $string2 ]   如果string1不等于string2，则为真   
if  [ -n $string  ]             如果string 非空(非0），返回0(true)  
if  [ -z $string  ]             如果string 为空，则为真
if  [ $sting ]                  如果string 非空，返回0 (和-n类似) 

逻辑非 !   条件表达式的相反
if [ ! 表达式 ]
if [ ! -d $num ]   如果不存在目录$num

逻辑与 –a 条件表达式的并列
if [ 表达式1  –a  表达式2 ]

逻辑或 -o 条件表达式的或
if [ 表达式1  –o 表达式2 ]


#!/bin/bash
echo "Please enter a number"
read num
if [ -z $num ]                  #判断是否输入了数字
then
echo "you enter nothing,please enter a number"
read num
else
        if [ $num -lt 0 -o $num -gt 100 ]     #判断数据是否合法
        then
        echo "The number is invalid,please enter a number"
        read num
        else
                if [ $num -ge 90 ]    #大于等于90，成绩等级为A
                then
                echo "The grade is A"
                else
                        if [ $num -ge 80 ]     #大于等于80，成绩等级为B
                        then
                        echo "The grade is B"
                        else
                                if [ $num -ge 70 ]     #大于等于70，等级等级为C
                                then
                                echo "The grade is C"
                                else
                                        if [ $num -ge 60 ]    #大于等于60，成绩等级为D
                                        then
                                        echo "The grade is D"
                                        else
                                        echo "The grade is E"    #小于60，成绩等级为E
                                        fi
                                fi
                        fi
                fi
        fi
fi

##--------------------------------------------------------
# !/bin/bash
echo "please input your grade:"
read a
    if [ $a -ge 90 ]    #大于 -gt (greater than) 
    then                #小于 -lt (less than) 
    echo 'A'            #大于或等于 -ge (greater than or equal) 
    elif [ $a -ge 80 ]  #小于或等于 -le (less than or equal) 
    then                #不相等 -ne （not equal）
    echo 'B'
    elif [ $a -ge 70 ]
    then 
    echo 'C'
    elif [ $a -ge 60 ]
    then 
    echo 'D'
    else
    echo 'E'
    fi 

### ---------------------------------
IF条件判断
 
1、基本语法:
if [ command ]; then
   符合该条件执行的语句
fi
 
2、扩展语法：
if [ command ];then
   符合该条件执行的语句
elif [ command ];then
   符合该条件执行的语句
else
   符合该条件执行的语句
fi
 
5：两个变量判断是否相等
if [ "$var1" = "$var2" ]; then
　　echo '$var1 eq $var2'
else
　　echo '$var1 not eq $var2'
fi

## ----------- ---------- ---------- ----------

$#：传入脚本的参数个数；
 
$0:  脚本自身的名称；　　
 
$1:  传入脚本的第一个参数；
 
$2:  传入脚本的第二个参数；
 
$@: 传入脚本的所有参数；
 
$*：传入脚本的所有参数；
 
$$:  脚本执行的进程id；
 
$?:  上一条命令执行后的状态，结果为0表示执行正常，结果为1表示执行异常；
 
其中$@与$*正常情况下一样，当在脚本中将$*加上双引号作为“$*”引用时，此时将输入的所有参数当做一个整体字符串对待。比如输入参数有a b c三个参数，则“$*”表示“a b c”一个字符串。

```

#### 案例-石头-剪刀-布

```shell
#!/bin/bash

# 1. 石头， 2: 剪刀， 3:布, 随机数求模后+1， 结果为1,2,3
computer=$[RANDOM%3+1]
clear
echo "################################"
echo "#         石头剪刀布           #"
echo "###############################"
echo "|------------------------------|"
echo "|  1. 石头                     |"
echo "|  2. 剪刀                     |"
echo "|  3. 布                       |"
read -p "请输入1~3的值: " person
clear
case $person in
1)
   if [[ "$computer" == 1 ]];then
      echo "-----------------------"
      echo "|     出拳：石头       |"
      echo "|  计算机出拳： 石头   |"
      echo "-----------------------"
      echo "|        平局          |"
   elif [[ "$computer" == 3 ]];then
      echo "-----------------------"
      echo "|     出拳：石头      |"
      echo "|  计算机出拳：剪刀   |"
      echo "|---------------------|"
      echo "|     恭喜，你赢了    |"
  elif [[ "$computer" == 3 ]];then
      echo "----------------------|"
      echo "|     出拳：石头      |"
      echo "|     计算机出拳：布  |"
      echo "|---------------------|"
      echo "|     计算机赢了      |"
   fi
esac
```

#### 循环

* for
* while
* until
* select

##### for + 序列生成

```shell

for name [ in [ word... ] ]
  do
    命令序列
done
# world 是可选的执行扩展的项目列表，扩展后生成一份完整的项目列表

#!/bin/bash
for i in 1 2 3 4 5
do
  echo "hello World $i"
done

# 不写 in
#!/bin/bash
for i
do
  echo "hello World $i"
done

这样 i 的取值就是 $@ 也就是所有的位置变量的值
# 没有位置参数，循环次数为0
[root@slave2 ~]# bash sys_var.sh

# 有位置参数，循环次数为位置参数的个数
[root@slave2 ~]# bash sys_var.sh 1 2 3 4 5
hello World 1
hello World 2
hello World 3
hello World 4
hello World 5

# 有扩展功能的word示例，Shell支持多种扩展，如变量替换、命令扩展、算术扩展、通配符扩展等

# hell支持使用seq或{}自动生成数字序列，并且使用{}还可以自动生成字母序列。
# for循环语句可以对{}或seq扩展后的数据列表进行循环
[root@slave2 ~]# echo {1..5}
1 2 3 4 5
[root@slave2 ~]# echo {a..b}
a b
[root@slave2 ~]# echo {a..f}
a b c d e f
[root@slave2 ~]# echo {A..F}
A B C D E F

# 带步长
[root@slave2 ~]# echo {1..10..2}
1 3 5 7 9

# 生成组合的字符串序列
[root@slave2 ~]# echo {x,y{i,j}{1,2,3},z}
x yi1 yi2 yi3 yj1 yj2 yj3 z

# {} 中不能适用变量， 没有生成序列
[root@slave2 ~]# a=2
[root@slave2 ~]# echo {1..10..$a}
{1..10..2}


# 适用 seq
[root@slave2 ~]# seq 1 5
1
2
3
4
5

# 指定空格分隔符
[root@slave2 ~]# seq -s  " " 1 5
1 2 3 4 5

# 指定逗号分隔符
[root@slave2 ~]# seq -s  "," 1 5
1,2,3,4,5
# 第二个参数为步长
[root@slave2 ~]# seq -s  "," 1 2 7
1,3,5,7

```

#### for 案例

```shell
#!/bin/bash
num=$[RANDOM%100]
count=0
while :
do
  read -p "一个1~100的随机数，你猜是多少：" guess
  # 使用正则匹配是否输入了字母或者符号等无效输入
  # [[ $guss =~ [[:alpha:]] || $guess =~ [[:punct:]] ]] && echo "无效输入" && exit
  let count++
  if [ $guess -eq $num ];then
     echo "猜对了，总共有$count次！"
     exit
  elif [ $guess -gt $num ];then
     echo "Oops, 猜大了"
  else
     echo "Oops, 猜小了"
  fi
done#!/bin/bash
# 功能描述: 判断有序的数字是否为闰年
# 条件1：能被4整除，但是不能被100整除
# 或者
# 条件2：能被 400 整除
for i in {1..500}
do
   if [[ ${i%4 } -eq 0 && ${i%100} -ne 0 || ${i%400} -eq 0 ]];then
      echo "$i 是闰年"
   else
      echo "$i 非闰年"
   fi
done

# 支持 C 语言中的for循环语法
for ((expr1; expr2; expr3))
do
   命令序列
done

#!/bin/bash
for i in {1..8}
do
  for j in {1..8}
  do
    sum=$[i+j]
    if [[ $[sum%2] -ne 0 ]];then
       echo -ne "\033[41m \033[0m"
    else
       echo -ne "\033[47m \033[0m"
    fi
  done
  echo
done

#!/bin/bash
for ((i=1;i<=9;i++))
do
   for ((j=1;j<=i;j++))
   do
     echo -n "$i*$j=$[i*j]"
   done
   echo
done


while 条件判断
do
   命令序列
done

#!/bin/bash
sum=0;i=1
while [ $i -le 100 ]
do
  let sum+=$i
  let i++
done
echo -e "1+2+3+4+..+100 的总和为：\033[1;32m$sum\033[0m"

# while 中的判断即可是任意可以执行的命令，只要语句返回码为0就代表为真


#!/bin/bash

while ps aux | grep -v grep | grep -q httpd
do
  clear
  echo "   httpd 运行状态   "
  echo "--------------------"
  echo -e "\033[32mHttp 正在运行中...\033[0m"
  echo "------------------------------------"
  sleep 0.5
done
  echo "Http 关闭"


#!/bin/bash
while :
do
  echo "hello world"
done

# 等同于
#!/bin/bash
while true
do
  echo "hello world"
done

#!/bin/bash
num=$[RANDOM%100]
count=0
while :
do
  read -p "一个1~100的随机数，你猜是多少：" guess
  # 使用正则匹配是否输入了字母或者符号等无效输入
  # [[ $guss =~ [[:alpha:]] || $guess =~ [[:punct:]] ]] && echo "无效输入" && exit
  let count++
  if [ $guess -eq $num ];then
     echo "猜对了，总共有$count次！"
     exit
  elif [ $guess -gt $num ];then
     echo "Oops, 猜大了"
  else
     echo "Oops, 猜小了"
  fi
done

## read 读取文件中的数据
# 结合 while 可以批量的从文件中读取数据并给变量赋值
[root@slave2 ~]# read key1 key2 key3
1 2 3
# 如果输入一个值的时候，那么key1为输入值，key2和key3 均是为空
#!/bin/bash
while read line
do
   echo -ne "\033[1;32mI said:\033[0m"
   echo "$line"
done < test.txt
# 读取 test.txt 文件中的内容
[root@slave2 ~]# bash sys_var.sh
I said:hello world
I said:welcome to beijing
I said:Hi sa
I said:dsfds

#!/bin/bash
while read k v
do
   echo -ne "\033[1;32mI said:\033[0m"
   echo "key: $k -- v: $v"
done < test.txt
# 同样，read 后面定义两个变量，k和v，在文件test.txt 
# 中空格前赋值给k，空格后赋值给 v
I said:key: hello -- v: world
I said:key: welcome -- v: to beijing
I said:key: Hi -- v: sa
I said:key: dsfds -- v:




```

#### 数组和函数

Bash仅支持一维索引数组和关联数组， bash 对数组没有大小限制

```shell
[root@slave2 ~]# name[0]=1
[root@slave2 ~]# name[1]=2
[root@slave2 ~]# name[2]=3
[root@slave2 ~]# name[2+2]=5
[root@slave2 ~]# echo ${name[4]}
5
[root@slave2 ~]# echo ${name[3]}

[root@slave2 ~]# echo ${name[2]}
3
[root@slave2 ~]# name[5]=nihaome
[root@slave2 ~]# echo ${name[5]}
nihaome

# 数组中最后一个元素
[root@slave2 ~]# echo ${name[-1]}
nihaome

# 数组中倒数第二个元素
[root@slave2 ~]# echo ${name[-2]}
5

# ${$name[*]} 将所有数组元素视为一个整体，所以for 循环值循环依次就结束，变量i也
# 只取到1次值

# ${name[@]} 将 name 中所有的值视为独立的个体，所以name 中有多个个元素，for 
# 循环就有多少个元素，循环多少次

[root@slave2 ~]# for i in "${name[*]}"; do  echo $i; done
1 2 3 5 nihaome
[root@slave2 ~]# for i in "${name[@]}"; do  echo $i; done
1
2
3
5

# 索引可以是变量
[root@slave2 ~]# a=1
[root@slave2 ~]# echo ${name[$a]}
2

#!/bin/bash
fibo=(1 1)
read -p "请输入需要计算的斐波那契数列个数: " num
for ((i=2;i<=num;i++))
do
  let fibo[$i]=fibo[$i-1]+fibo[$-2]
done
echo ${fibo[@]}
```
