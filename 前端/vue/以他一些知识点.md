#### `v-if`  和 `v-show` 的区别

* 相同点

> `v-if` 和 `v-show` 都可以动态控制 `dom` 元素的显示和隐藏

* 不同点

> `v-if` 显示隐藏是将`dom` 元素整个添加或者删除，而`v-show` 隐藏是将该元素添加`css--display:none`，`dom` 元素还在的。

*注意*

> `v-if` 是动态的添加或者删除`dom` 元素，或有一个局部编译/卸载过程
>
> `v-show`仅仅是修改了`css` 样式



#### Vue 数据的双向绑定

`vue.js` 是采用**数据劫持结合发布者-订阅者模式**的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤：

第一步：需要`observe`的数据对象进行递归遍历，包括子属性对象的属性，都加上 `setter`和`getter` 这样的话，给这个对象的某个值赋值，就会触发`setter`，那么就能监听到了数据变化
第二步：`compile`解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
第三步：`Watcher`订阅者是`Observer`和`Compile`之间通信的桥梁，主要做的事情是:

在自身实例化时往属性订阅器(dep)里面添加自己
自身必须有一个`update()`方法
待属性变动`dep.notice()`通知时，能调用自身的`update()`方法，并触发`Compile`中绑定的回调，则功成身退。

第四步：`MVVM`作为数据绑定的入口，整合`Observer`、`Compile`和`Watcher`三者，

* 通过`Observer`来监听自己的`model`数据变化，
* 通过`Compile`来解析编译模板指令，最终利用`Watcher`搭起`Observer`和`Compile`之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。



#### Vue的生命周期

答：总共分为8个阶段:

* 创建前/后:  创建实例

  > vue实例的挂载元素$el和数据对象**data**都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。

  * `beforeCreate`： 无法通过 vm 访问到 data 中的数据，methods 中的方法
  * `created`： 无法通过 vm 访问到 data 中的数据，methods 中的方法(数据监测和数据代理完毕)

  > vue 开始解析模板，生成虚拟DOM(内存)，页面还不能显示解析好的内容

* 载入前/后: 完成模板的解析，并把初始化的真实DOM元素放入页面后(挂载完毕)调用 mounted

  * `beforeMount`: 页面呈现的是未经 vue 编译的 DOM 结构
  * `Mounted`：呈现的一级是 vue 编译的DOM，对DOM 的操作均有效，至此完成初始化过程结束，一般在此进行，开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作

* 更新前/后： 当**data**变化时

  * `beforeUpdate`: 当数据发生更新时候，数据是新的，但是页面还是旧的，页面尚未和数据保持同步
  * `afterUpdate`: 执行到这里，根据新的数据，生成了新的虚拟DOM，随后和旧的虚拟DOM 进行比较，最终完成页面更新，到达这里，页面和数据保持着同步

* 销毁前/后

  > 在执行destroy方法后，对**data**的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

<img src=".\pics\life-cycle.png" alt="life-cycle" style="zoom:50%;" />

#### 封装 vue 组件的过程

首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。

然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。



#### watch 和 computed 属性



#### ref 属性

原生的 `dom`

> ```html
> <h1 v-text="msg" id='title'></h1>
> ```
>
> 可以通过
>
> ```html
> h1 = window.getElementById('title')
> ```

在 `vue` 中是屏蔽掉对 `dom` 的操作的，`ref` 就是用来的在 `vue` 中获取元素的

> ```html
> <h1 v-text="msg" ref='title'></h1>
> h2 = this.$refs.title
> ```

#### props 属性

调用自定义组件的时候给组件传递参数

，如现在有 `Student` 自定义组件

```vue
<template>
	<div>
        <h1>{{msg}}</h1>
        <h1>姓名：{{name}}</h1>
        <h1>性别：{{sex}}</h1>
        <h1>年龄：{{age}}</h1>
    </div>
</template>

<script>
	export default {
        name: 'student',
        data () {
            msg: 'xxxx',
            // 读到 props 中的age，然后赋值到这里，后续可以修改这里的值，不去修改 props.age 中额值
            myAge: this.age
        },
        // props:['name','sex','age'] 简单接受
        // 声明类型接受
        //props: {
        //    name: string,
         //   age: Number,
        //    sex: String
        //}
        // 最完整的写法， 接受到的 props 是不能改的
        props: {
            name: {
            	type: String,
            	requred: true,// 必传 
        	},
            age: {
                type: Number,
                default: 99 // 默认值
            } 
        }
    }
</script>

//---  使用的时候
<Student name="aaa" sex="bbbb" age="aads">
```



#### el 属性



#### vuex

> vue 中实现集中式状态(数据) 管理的一个 vue 插件，对 vue 应用中的多个组件的共享状态进行集中式的管理(读写),也是一种组件间通信的方式，适合任意组件之间的通信 

什么时候使用 Vuex

* 多个组件依赖于同一个状态
* 来自多个不同组件的行为需要变更同一个状态

1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用

![a](.\pics\vuex.png)

举个加法的例子

1.  `Dispatch('jiafa', 2)`, 分发一个 `jiafa` 的动作, 只是给别人说，我要做加法，去加2这个数字
2. 二在 `Action` 中一定会有一个 `key=jiafa` ，`value`其是一个函数，执行这个函数，但是有时候执行函数的时候还需要其他外界的参数，就需要去拿这些参数，然后在去 `commit` 这个函数到`mutation`
3. 执行了`mutate`, 最终执行函数
4. 返回更新状态

当然还有情况是，之间`commit` 到`mutation` 计算结果。

好比生活中的例子：

> 去饭馆吃饭，点菜
>
> 1. 在服务员那点菜(dispatch)
> 2. 服务员将菜反馈给厨房(commit)
> 3. 厨房做饭`mutation`
> 4. 菜上桌了

```vue
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)

const actions = {
	jiaOdd(context,value){
		console.log('actions中的jiaOdd被调用了')
		if(context.state.sum % 2){
			context.commit('JIA',value)
		}
	}
}
//准备mutations——用于操作数据（state）
const mutations = {
	JIA(state,value){
		console.log('mutations中的JIA被调用了')
		state.sum += value
	},
	JIAN(state,value){
		console.log('mutations中的JIAN被调用了')
		state.sum -= value
	}
}
//准备state——用于存储数据
const state = {
	sum:0 //当前的和
}

//创建并暴露store
export default new Vuex.Store({
	actions,
	mutations,
	state,
})

----
import store from './store'

//关闭Vue的生产提示
Vue.config.productionTip = false
//使用插件
Vue.use(vueResource)

//创建vm
new Vue({
	el:'#app',
	render: h => h(App),
	store,
	beforeCreate() {
		Vue.prototype.$bus = this
	}
})

--- 使用
methods: {
increment(){
	this.$store.commit('JIA',this.n)
},
decrement(){
	this.$store.commit('JIAN',this.n)
},
incrementOdd(){
	this.$store.dispatch('jiaOdd',this.n)
},
incrementWait(){
	this.$store.dispatch('jiaWait',this.n)
	},
},
```

#### 子给父组件传数据

1. 父亲将函数传给子，子组件在调用函数的时候将子的数据传给父亲

   ```vue
   // 父组件
   <School :getSchoolName="getSchoolName"/>
   
   getSchoolName(name){
   	console.log('App收到了学校名：',name)
   },
   
   // 子组件
   <button @click="sendSchoolName">把学校名给App</button>
   
   export default {
   		name:'School',
   		props:['getSchoolName'], // 父组件传过来的
   		data() {
   			return {
   				name:'尚硅谷',
   				address:'北京',
   			}
   		},
   		methods: {
   			sendSchoolName(){
   				this.getSchoolName(this.name) // 调用父组件传过来的函数，并将子的数据穿过去
   			}
   		},
   	}
   ```

   2. **自定义事件**

   ```vue
   <Student @atguigu="getStudentName" @demo="m1"/> 
   <Student @atguigu.once="getStudentName" @demo="m1"/> // 只触发一次
   getStudentName(name,...params){
   	console.log('App收到了学生名：',name,params)
   	this.studentName = name
   },
   // @atguigu == v-on:atguigu, 给Student 绑定一个事件，当这个事件触发，那么就执行getStudentName方法
   // 给谁定义自定义事件，谁去触发
   
   -- 子组件，定义触发自定义事件
   <button @click="sendStudentlName">把学生名给App</button>
   sendStudentlName(){
       //触发Student组件实例身上的atguigu事件
       this.$emit('atguigu',this.name,666,888,900)
       // this.$emit('demo')
       // this.$emit('click')
   },
   ```

   和父组件给子组件传递函数相比，自定义事件完成子组件给父组件传递数据，父组件不需要给子组件传递东西。

   ** 第二种自定义事件实现子向父传递的方法 **

   ```vue
   <Student ref="student"/>
   // 当 Student 和 ref 挂载结束后
   mounted() {
   // 这里还z可以执行若干逻辑，
   	this.$refs.student.$on('atguigu',this.getStudentName) //绑定自定义事件，on 监听事件，当student 触发 atguigu 后执行回调 
   	this.$refs.student.$on('atguigu',this.getStudentName) // 另外一个API，只能触发一次
   },
   ```

   1.  

