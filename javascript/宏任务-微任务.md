### 事件循环

`JavaScript` 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、`UI` 渲染和网络处理等行为，防止主线程的不阻塞，`Event Loop` 的方案应用而生。`Event Loop` 包含两类：一类是基于 [Browsing Context](https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/browsers.html%23browsing-context)，一种是基于 [Worker](https://link.zhihu.com/?target=https%3A//www.w3.org/TR/workers/%23worker)。二者的运行是独立的，也就是说，每一个 `JavaScript` 运行的"线程环境"都有一个独立的` Event Loop`，每一个 `Web Worker` 也有一个独立的 `Event Loop`。



### 任务队列

一个` Event Loop` 中，可以有一个或者多个任务队列(`task queue`)，一个任务队列便是一系列有序任务(`task`)的集合；每个任务都有一个任务源(`task source`)，源自同一个任务源的` task` 必须放到同一个任务队列，从不同源来的则被添加到不同队列。`setTimeout/Promise` 等`API`便是任务源，而进入任务队列的是他们指定的具体执行任务。

在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

- 在此次 tick 中选择最先进入队列的任务(oldest task)，如果有则执行(一次)
- 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue
- 更新 render
- 主线程重复执行上述步骤

在上诉tick的基础上需要了解几点：

- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
- **一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。**

### 宏任务

(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。

浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下：

### 宏任务包含

```text
script(整体代码)
setTimeout
setInterval
I/O
UI交互事件
postMessage
MessageChannel
setImmediate(Node.js 环境)
```

### 微任务



