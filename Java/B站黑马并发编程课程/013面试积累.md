#### cpu、核与线程关系

>  **物理 cpu 数**: 主板上的 cpu 插槽
>
> **核心(core)**: 单个物理 cpu 上增加核心（实实在在的硬件存在），也就出现了双核心 cpu（dual-core cpu）以及多核心 cpu（multiple cores），这样一个双核心 cpu 就是同一时刻能够运行两个进程/线程的。
>
> **同时多线程技术（simultaneous multithreading）和 超线程技术（hyper–threading/HT）**
>
> 本质一样，是为了提高单个 core 同一时刻能够执行的多线程数的技术（充分利用单个 core 的计算能力，尽量让其 **一刻也不得闲**）。
>
> 在类似技术下，产生了如下等价术语：
>
> - 虚拟 core： virtual core
> - 逻辑 processer： logical processor
> - 线程：thread
>
> 所以可以这样说：某款采用 SMT 技术的 4 核心 AMD cpu 提供了 8 线程同时执行的能力；某款采用 HT 技术的 2 核心 Intel cpu 提供了 4 线程同时执行的能力。

- 一台完整的计算机可能包含一到多个物理 cpu
- 从单个物理 cpu （physical cpu）的角度看，其可能是单核心、双核心甚至多核心的
- 从单个核心（core）的角度看，还有 SMT / HT 等技术让每个 core 对计算机操作系统而言用起来像多个物理 core 差不多

---

#### 为什么要用到并发

> 硬件的发展，不在遵循"摩尔定律"， 硬件本身带来的计算能力的提升收到瓶颈，于是从软件方面着手，提供计算机的计算速度。
>
> 并发编程的趋势，通过**并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升**。
>
> * 使用并发编程可以
>
> 1. 复杂业务拆解，多线程执行，提高效率
>
> * 并发编程缺点
>   1. 频繁上下文切换，一般几十毫秒，如果计算任务比较轻量，那么多线程上下文切换带来的损耗大于线程本身执行时间，这个时候使用多线程是得不偿失的。一般上下文切换需要保存当前的状态，一般线程恢复之前的状态。
>   2. 减少上下文切换。使用无锁编程`CAS` 算法
>   3. 减少上下文切换。避免创建不需要的线程，比如任务很少。
>   4. 减少上下文切换。协程

##### 应该了解的概念

* 同步/异步

* 并发并行

* 阻塞和非阻塞

  > 阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了**临界区资源**，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，

* 临界区

  > **公共资源或者说是共享数据**，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。

#### 创建线程的三种方式

* 继承 `Thread` ，重写 `run`
* 实现`Runnable` 接口， `FutureTask` 也是继承了`Runnable`  方法的 
* 实现`Callable` 接口

#### 线程状态转换

#### 基本操作

1. `interrupt`
2. `join`
3. `sleep`
4. `Daemon` 守护线程

#### Java 内存模型以及`hadppens-before 规则`

* 什么是线程不安全呢？

  > 多线程下代码执行的结果与预期正确的结果不一致，该代码就是线程不安全的，否则则是线程安全的

* 导致线程不安全原因

  > 一般是因为**主内存和工作内存数据不一致性**和**指令重排序**导致的

* 那些变量是共享变量

  > 在`JVM`  中的`堆` 中创建的变量是共享的，如实例域、静态域、数组元素域

* 内存模型

* happens-before定义

#### `synchronized` 理解